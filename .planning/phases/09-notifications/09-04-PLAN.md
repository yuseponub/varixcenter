---
phase: 09-notifications
plan: 04
type: execute
wave: 2
depends_on: ["09-01", "09-03"]
files_modified:
  - src/lib/queries/notifications.ts
  - src/app/api/cron/send-reminders/route.ts
  - vercel.json
autonomous: true
user_setup:
  - service: vercel
    why: "Cron job authentication"
    env_vars:
      - name: CRON_SECRET
        source: "Generate random string (16+ chars): openssl rand -hex 16"
    dashboard_config:
      - task: "Add CRON_SECRET to Vercel Environment Variables"
        location: "Vercel Dashboard -> Project -> Settings -> Environment Variables"

must_haves:
  truths:
    - "Cron endpoint runs every 15 minutes"
    - "Only authorized requests with CRON_SECRET can trigger"
    - "Appointments 24h and 2h away receive reminders"
    - "Failed sends are scheduled for retry 30 min later"
    - "Duplicate reminders are prevented by database constraint"
  artifacts:
    - path: "src/app/api/cron/send-reminders/route.ts"
      provides: "Cron endpoint for sending reminders"
      exports: ["GET"]
    - path: "src/lib/queries/notifications.ts"
      provides: "Query functions for notifications"
      exports: ["getAppointmentsNeedingReminder", "createNotification", "updateNotificationStatus"]
    - path: "vercel.json"
      provides: "Cron schedule configuration"
      contains: "*/15 * * * *"
  key_links:
    - from: "src/app/api/cron/send-reminders/route.ts"
      to: "src/lib/twilio/sms.ts"
      via: "sendSMS import"
      pattern: "import.*sendSMS.*from.*twilio"
    - from: "src/app/api/cron/send-reminders/route.ts"
      to: "src/lib/queries/notifications.ts"
      via: "query imports"
      pattern: "import.*from.*queries/notifications"
---

<objective>
Create the cron API route that sends SMS reminders and the vercel.json cron configuration.

Purpose: Automated reminder sending triggered by Vercel Cron every 15 minutes. Queries upcoming appointments, sends SMS via Twilio, and tracks results in database.
Output: Cron endpoint, query functions, and vercel.json configuration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-notifications/09-RESEARCH.md
@src/lib/twilio/sms.ts
@src/lib/twilio/message-builder.ts
@src/types/notifications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification query functions</name>
  <files>src/lib/queries/notifications.ts</files>
  <action>
Create query functions for the notification system:

```typescript
/**
 * Notification Query Functions
 *
 * Database operations for SMS reminder system.
 * Uses service role client for cron job operations.
 */
import { createClient } from '@/lib/supabase/server'
import type {
  Notification,
  NotificationWithDetails,
  CreateNotificationData,
  ReminderType,
} from '@/types/notifications'
import { addHours, subMinutes, addMinutes } from 'date-fns'

/**
 * Appointment data needed for sending reminders
 */
interface AppointmentForReminder {
  id: string
  fecha_hora_inicio: string
  patients: {
    id: string
    nombre: string
    apellido: string
    celular: string
  }
}

/**
 * Get appointments that need a reminder of the specified type
 *
 * Uses a 1-hour window centered on the target time:
 * - For 24h reminder: appointments 23.5h to 24.5h from now
 * - For 2h reminder: appointments 1.5h to 2.5h from now
 *
 * Excludes appointments that already have a notification (enviado or pendiente)
 * for this reminder type.
 *
 * @param reminderType - '24h' or '2h'
 * @returns Appointments needing this reminder
 */
export async function getAppointmentsNeedingReminder(
  reminderType: ReminderType
): Promise<AppointmentForReminder[]> {
  const supabase = await createClient()
  const now = new Date()

  // Calculate window based on reminder type
  const hoursAhead = reminderType === '24h' ? 24 : 2
  const windowStart = subMinutes(addHours(now, hoursAhead), 30) // -30 min
  const windowEnd = addMinutes(addHours(now, hoursAhead), 30) // +30 min

  // First get appointments in the time window with active status
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: appointments, error: aptError } = await (supabase as any)
    .from('appointments')
    .select(`
      id,
      fecha_hora_inicio,
      patients!inner (
        id,
        nombre,
        apellido,
        celular
      )
    `)
    .gte('fecha_hora_inicio', windowStart.toISOString())
    .lte('fecha_hora_inicio', windowEnd.toISOString())
    .in('estado', ['programada', 'confirmada'])

  if (aptError) {
    console.error('[Notifications] Error fetching appointments:', aptError)
    throw aptError
  }

  if (!appointments || appointments.length === 0) {
    return []
  }

  // Get existing notifications for these appointments
  const appointmentIds = appointments.map((a: AppointmentForReminder) => a.id)

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: existingNotifications, error: notifError } = await (supabase as any)
    .from('notifications')
    .select('appointment_id')
    .in('appointment_id', appointmentIds)
    .eq('tipo_recordatorio', reminderType)
    .in('estado', ['pendiente', 'enviado', 'reintentando'])

  if (notifError) {
    console.error('[Notifications] Error checking existing:', notifError)
    throw notifError
  }

  // Filter out appointments that already have notifications
  const existingIds = new Set(
    (existingNotifications || []).map((n: { appointment_id: string }) => n.appointment_id)
  )

  return (appointments as AppointmentForReminder[]).filter(
    (apt) => !existingIds.has(apt.id) && apt.patients?.celular
  )
}

/**
 * Get notifications that need retry
 *
 * @returns Notifications in 'reintentando' state with retry time in the past
 */
export async function getNotificationsForRetry(): Promise<Notification[]> {
  const supabase = await createClient()
  const now = new Date().toISOString()

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from('notifications')
    .select('*')
    .eq('estado', 'reintentando')
    .lte('siguiente_reintento_at', now)
    .lt('intentos', 2) // Max 2 attempts (initial + 1 retry)

  if (error) {
    console.error('[Notifications] Error fetching retries:', error)
    throw error
  }

  return (data as Notification[]) || []
}

/**
 * Create a new notification record
 *
 * @param data - Notification data
 * @returns Created notification or null on constraint violation (duplicate)
 */
export async function createNotification(
  data: CreateNotificationData
): Promise<Notification | null> {
  const supabase = await createClient()

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data: notification, error } = await (supabase as any)
    .from('notifications')
    .insert({
      ...data,
      estado: 'pendiente',
      intentos: 0,
    })
    .select()
    .single()

  if (error) {
    // Unique constraint violation = duplicate notification
    if (error.code === '23505') {
      console.log('[Notifications] Duplicate prevented:', data.appointment_id, data.tipo_recordatorio)
      return null
    }
    console.error('[Notifications] Error creating:', error)
    throw error
  }

  return notification as Notification
}

/**
 * Update notification after send attempt
 *
 * @param id - Notification UUID
 * @param updates - Fields to update
 * @returns Updated notification
 */
export async function updateNotificationStatus(
  id: string,
  updates: {
    estado: 'enviado' | 'fallido' | 'reintentando'
    twilio_message_sid?: string | null
    error_code?: number | null
    error_message?: string | null
    enviado_at?: string | null
    siguiente_reintento_at?: string | null
    intentos?: number
  }
): Promise<Notification | null> {
  const supabase = await createClient()

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from('notifications')
    .update(updates)
    .eq('id', id)
    .select()
    .single()

  if (error) {
    console.error('[Notifications] Error updating status:', error)
    throw error
  }

  return data as Notification
}

/**
 * Get notification by ID
 */
export async function getNotificationById(id: string): Promise<Notification | null> {
  const supabase = await createClient()

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from('notifications')
    .select('*')
    .eq('id', id)
    .single()

  if (error) {
    if (error.code === 'PGRST116') return null
    throw error
  }

  return data as Notification
}

/**
 * Get notifications list with optional filters
 *
 * @param filters - Optional filters
 * @returns Array of notifications with patient and appointment details
 */
export async function getNotifications(filters?: {
  estado?: string
  tipo_recordatorio?: string
  patient_id?: string
  limit?: number
}): Promise<NotificationWithDetails[]> {
  const supabase = await createClient()
  const limit = filters?.limit ?? 50

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let query = (supabase as any)
    .from('notifications')
    .select(`
      *,
      patients!inner (
        id,
        nombre,
        apellido,
        celular
      ),
      appointments!inner (
        id,
        fecha_hora_inicio,
        estado
      )
    `)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (filters?.estado) {
    query = query.eq('estado', filters.estado)
  }
  if (filters?.tipo_recordatorio) {
    query = query.eq('tipo_recordatorio', filters.tipo_recordatorio)
  }
  if (filters?.patient_id) {
    query = query.eq('patient_id', filters.patient_id)
  }

  const { data, error } = await query

  if (error) {
    console.error('[Notifications] Error fetching list:', error)
    throw error
  }

  return (data as NotificationWithDetails[]) || []
}

/**
 * Get notifications for a specific patient (for timeline)
 */
export async function getPatientNotifications(
  patientId: string,
  limit = 10
): Promise<Notification[]> {
  const supabase = await createClient()

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any)
    .from('notifications')
    .select('*')
    .eq('patient_id', patientId)
    .order('created_at', { ascending: false })
    .limit(limit)

  if (error) {
    console.error('[Notifications] Error fetching patient notifications:', error)
    return []
  }

  return (data as Notification[]) || []
}
```
  </action>
  <verify>
File exists at src/lib/queries/notifications.ts with exports:
- getAppointmentsNeedingReminder
- getNotificationsForRetry
- createNotification
- updateNotificationStatus
- getNotificationById
- getNotifications
- getPatientNotifications
  </verify>
  <done>
Query functions created for all notification operations including appointment queries with time windows, retry management, and patient timeline support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cron API route</name>
  <files>src/app/api/cron/send-reminders/route.ts</files>
  <action>
Create the cron endpoint that sends SMS reminders:

```typescript
/**
 * Cron API Route: Send Appointment Reminders
 *
 * Triggered by Vercel Cron every 15 minutes.
 * Sends SMS reminders for appointments 24h and 2h away.
 *
 * Authentication: Bearer token matching CRON_SECRET env var.
 *
 * @see vercel.json for cron schedule configuration
 */
import type { NextRequest } from 'next/server'
import { addMinutes } from 'date-fns'
import { sendSMS, isPermanentError } from '@/lib/twilio/sms'
import { buildReminderMessage, sanitizePatientName } from '@/lib/twilio/message-builder'
import {
  getAppointmentsNeedingReminder,
  getNotificationsForRetry,
  createNotification,
  updateNotificationStatus,
} from '@/lib/queries/notifications'
import type { ReminderType } from '@/types/notifications'

// Force dynamic rendering (no caching)
export const dynamic = 'force-dynamic'

// Allow up to 60 seconds for cron execution
export const maxDuration = 60

/**
 * Verify cron request authentication
 */
function isAuthorized(request: NextRequest): boolean {
  const authHeader = request.headers.get('authorization')
  const cronSecret = process.env.CRON_SECRET

  if (!cronSecret) {
    console.error('[Cron] CRON_SECRET not configured')
    return false
  }

  return authHeader === `Bearer ${cronSecret}`
}

/**
 * Format phone number to E.164 format for Colombia
 * Input: "3001234567" or "+573001234567"
 * Output: "+573001234567"
 */
function formatPhoneE164(phone: string): string {
  // Remove all non-digits
  const digits = phone.replace(/\D/g, '')

  // If already has country code
  if (digits.startsWith('57') && digits.length === 12) {
    return `+${digits}`
  }

  // Add Colombia country code
  if (digits.length === 10 && digits.startsWith('3')) {
    return `+57${digits}`
  }

  // Return as-is if format unclear (will fail at Twilio with helpful error)
  return `+${digits}`
}

/**
 * Process reminders for a specific type (24h or 2h)
 */
async function processReminders(
  reminderType: ReminderType
): Promise<{ sent: number; failed: number; skipped: number }> {
  const results = { sent: 0, failed: 0, skipped: 0 }

  try {
    const appointments = await getAppointmentsNeedingReminder(reminderType)
    console.log(`[Cron] Found ${appointments.length} appointments for ${reminderType} reminder`)

    for (const apt of appointments) {
      // Skip if no phone number
      if (!apt.patients?.celular) {
        console.log(`[Cron] Skipping ${apt.id}: no phone number`)
        results.skipped++
        continue
      }

      // Build message
      const patientName = sanitizePatientName(apt.patients.nombre)
      const appointmentDate = new Date(apt.fecha_hora_inicio)
      const message = buildReminderMessage(patientName, appointmentDate, reminderType)
      const phoneE164 = formatPhoneE164(apt.patients.celular)

      // Create notification record (will fail if duplicate)
      const notification = await createNotification({
        appointment_id: apt.id,
        patient_id: apt.patients.id,
        tipo_recordatorio: reminderType,
        telefono_destino: phoneE164,
        mensaje: message,
      })

      if (!notification) {
        // Duplicate - already sent or pending
        results.skipped++
        continue
      }

      // Send SMS
      const smsResult = await sendSMS(phoneE164, message)

      if (smsResult.success) {
        // Update notification as sent
        await updateNotificationStatus(notification.id, {
          estado: 'enviado',
          twilio_message_sid: smsResult.messageSid || null,
          enviado_at: new Date().toISOString(),
          intentos: 1,
        })
        results.sent++
      } else {
        // Handle failure
        const shouldRetry = !isPermanentError(smsResult.errorCode ?? null)

        await updateNotificationStatus(notification.id, {
          estado: shouldRetry ? 'reintentando' : 'fallido',
          error_code: smsResult.errorCode ?? null,
          error_message: smsResult.errorMessage ?? null,
          intentos: 1,
          siguiente_reintento_at: shouldRetry
            ? addMinutes(new Date(), 30).toISOString()
            : null,
        })
        results.failed++
      }
    }
  } catch (error) {
    console.error(`[Cron] Error processing ${reminderType} reminders:`, error)
  }

  return results
}

/**
 * Process retry queue
 */
async function processRetries(): Promise<{ sent: number; failed: number }> {
  const results = { sent: 0, failed: 0 }

  try {
    const notifications = await getNotificationsForRetry()
    console.log(`[Cron] Found ${notifications.length} notifications to retry`)

    for (const notif of notifications) {
      // Retry send
      const smsResult = await sendSMS(notif.telefono_destino, notif.mensaje)

      if (smsResult.success) {
        await updateNotificationStatus(notif.id, {
          estado: 'enviado',
          twilio_message_sid: smsResult.messageSid || null,
          enviado_at: new Date().toISOString(),
          intentos: notif.intentos + 1,
        })
        results.sent++
      } else {
        // Mark as failed after retry (max 2 attempts)
        await updateNotificationStatus(notif.id, {
          estado: 'fallido',
          error_code: smsResult.errorCode ?? null,
          error_message: smsResult.errorMessage ?? null,
          intentos: notif.intentos + 1,
          siguiente_reintento_at: null,
        })
        results.failed++
      }
    }
  } catch (error) {
    console.error('[Cron] Error processing retries:', error)
  }

  return results
}

/**
 * GET handler for cron endpoint
 */
export async function GET(request: NextRequest) {
  // Verify authorization
  if (!isAuthorized(request)) {
    console.warn('[Cron] Unauthorized request')
    return new Response('Unauthorized', { status: 401 })
  }

  console.log('[Cron] Starting reminder job at', new Date().toISOString())

  const results = {
    timestamp: new Date().toISOString(),
    reminders_24h: { sent: 0, failed: 0, skipped: 0 },
    reminders_2h: { sent: 0, failed: 0, skipped: 0 },
    retries: { sent: 0, failed: 0 },
  }

  try {
    // Process 24h reminders
    results.reminders_24h = await processReminders('24h')

    // Process 2h reminders
    results.reminders_2h = await processReminders('2h')

    // Process retry queue
    results.retries = await processRetries()

    console.log('[Cron] Job completed:', results)

    return Response.json({
      success: true,
      ...results,
    })
  } catch (error) {
    console.error('[Cron] Job failed:', error)

    return Response.json(
      {
        success: false,
        error: 'Internal error',
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    )
  }
}
```
  </action>
  <verify>
File exists at src/app/api/cron/send-reminders/route.ts with:
- GET export
- Authorization check using CRON_SECRET
- Processing for 24h and 2h reminders
- Retry processing
- Phone number E.164 formatting
  </verify>
  <done>
Cron endpoint created with:
- Bearer token authentication
- 24h and 2h reminder processing
- Retry logic for failed sends (30 min delay, max 1 retry)
- Phone number E.164 formatting
- Comprehensive logging
  </done>
</task>

<task type="auto">
  <name>Task 3: Create vercel.json with cron schedule</name>
  <files>vercel.json</files>
  <action>
Create vercel.json at project root with cron configuration:

```json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "crons": [
    {
      "path": "/api/cron/send-reminders",
      "schedule": "*/15 * * * *"
    }
  ]
}
```

This configures the cron to run every 15 minutes.

Note: On Vercel Hobby plan, cron may execute with up to 1 hour variation.
The 1-hour window in our appointment query handles this.
  </action>
  <verify>
File exists at vercel.json with:
- crons array
- path: "/api/cron/send-reminders"
- schedule: "*/15 * * * *"
  </verify>
  <done>
Vercel cron configuration created to trigger reminder endpoint every 15 minutes.
  </done>
</task>

</tasks>

<verification>
- [ ] src/lib/queries/notifications.ts exists with all query functions
- [ ] src/app/api/cron/send-reminders/route.ts exists with GET handler
- [ ] vercel.json exists with cron schedule
- [ ] Cron endpoint requires CRON_SECRET authorization
- [ ] Phone numbers are formatted to E.164 before sending
- [ ] Retry logic schedules retry 30 min later for non-permanent errors
- [ ] Duplicate prevention via database constraint
- [ ] TypeScript compiles without errors: `npx tsc --noEmit`
</verification>

<success_criteria>
Cron system is complete and ready for deployment. When deployed to Vercel with env vars configured, will automatically send SMS reminders for appointments 24h and 2h away. Failed sends are retried once after 30 minutes.
</success_criteria>

<output>
After completion, create `.planning/phases/09-notifications/09-04-SUMMARY.md`
</output>
