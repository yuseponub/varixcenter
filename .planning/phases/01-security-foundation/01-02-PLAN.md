---
phase: 01-security-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/001_user_roles.sql
  - supabase/migrations/002_audit_infrastructure.sql
  - supabase/migrations/003_custom_access_token_hook.sql
autonomous: true
user_setup:
  - service: supabase
    why: "Enable Custom Access Token Hook in dashboard"
    dashboard_config:
      - task: "Enable Custom Access Token Hook"
        location: "Supabase Dashboard -> Authentication -> Hooks -> Custom Access Token -> Enable and set function to public.custom_access_token_hook"

must_haves:
  truths:
    - "user_roles table exists with RLS enabled"
    - "audit_log table exists with RLS enabled (append-only)"
    - "get_user_role() function returns role from JWT"
    - "custom_access_token_hook injects role into JWT claims"
  artifacts:
    - path: "supabase/migrations/001_user_roles.sql"
      provides: "User roles table and RLS"
      contains: "CREATE TABLE public.user_roles"
    - path: "supabase/migrations/002_audit_infrastructure.sql"
      provides: "Audit log table and helper functions"
      contains: "CREATE TABLE public.audit_log"
    - path: "supabase/migrations/003_custom_access_token_hook.sql"
      provides: "JWT role injection hook"
      contains: "CREATE OR REPLACE FUNCTION public.custom_access_token_hook"
  key_links:
    - from: "public.custom_access_token_hook"
      to: "public.user_roles"
      via: "SELECT role query"
      pattern: "SELECT role INTO user_role FROM public.user_roles"
    - from: "public.get_user_role"
      to: "auth.jwt()"
      via: "JWT claim extraction"
      pattern: "auth\\.jwt\\(\\) -> 'app_metadata'"
---

<objective>
Create database schema for role-based access control and immutable audit logging.

Purpose: Establish the security foundation at the database level with RLS-enabled tables, role management, and audit infrastructure that captures all data changes.
Output: SQL migrations ready to apply to Supabase, implementing user_roles, audit_log, and custom access token hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user_roles table and get_user_role helper</name>
  <files>supabase/migrations/001_user_roles.sql</files>
  <action>
Create SQL migration for user roles infrastructure:

```sql
-- Migration: 001_user_roles.sql
-- Purpose: Role-based access control foundation

-- Create enum for user roles
CREATE TYPE public.user_role AS ENUM ('admin', 'medico', 'enfermera', 'secretaria');

-- User roles table
CREATE TABLE public.user_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role public.user_role NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(user_id)
);

-- Index for faster lookups
CREATE INDEX idx_user_roles_user_id ON public.user_roles(user_id);

-- Enable RLS
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- Only admins can manage roles
CREATE POLICY "Admins can view all roles" ON public.user_roles
FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM public.user_roles ur
        WHERE ur.user_id = (SELECT auth.uid())
        AND ur.role = 'admin'
    )
);

CREATE POLICY "Admins can insert roles" ON public.user_roles
FOR INSERT
TO authenticated
WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.user_roles ur
        WHERE ur.user_id = (SELECT auth.uid())
        AND ur.role = 'admin'
    )
);

CREATE POLICY "Admins can update roles" ON public.user_roles
FOR UPDATE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM public.user_roles ur
        WHERE ur.user_id = (SELECT auth.uid())
        AND ur.role = 'admin'
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.user_roles ur
        WHERE ur.user_id = (SELECT auth.uid())
        AND ur.role = 'admin'
    )
);

CREATE POLICY "Admins can delete roles" ON public.user_roles
FOR DELETE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM public.user_roles ur
        WHERE ur.user_id = (SELECT auth.uid())
        AND ur.role = 'admin'
    )
);

-- Helper function to get current user's role from JWT
-- SECURITY DEFINER to avoid RLS recursion, STABLE for caching
CREATE OR REPLACE FUNCTION public.get_user_role()
RETURNS text
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT COALESCE(
        (SELECT auth.jwt() -> 'app_metadata' ->> 'role'),
        'none'
    )
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION public.get_user_role TO authenticated;

-- Updated_at trigger
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;

CREATE TRIGGER tr_user_roles_updated_at
    BEFORE UPDATE ON public.user_roles
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
```

Create directory `supabase/migrations/` if it doesn't exist.
  </action>
  <verify>
    - File exists at supabase/migrations/001_user_roles.sql
    - Contains CREATE TABLE public.user_roles
    - Contains get_user_role() function
    - RLS enabled with admin-only policies
  </verify>
  <done>User roles table and get_user_role helper function created with strict RLS</done>
</task>

<task type="auto">
  <name>Task 2: Create audit log infrastructure</name>
  <files>supabase/migrations/002_audit_infrastructure.sql</files>
  <action>
Create SQL migration for immutable audit logging:

```sql
-- Migration: 002_audit_infrastructure.sql
-- Purpose: Immutable audit log capturing all data changes

-- Helper function to get request header (PostgREST provides these)
CREATE OR REPLACE FUNCTION public.get_request_header(header_name text)
RETURNS text
LANGUAGE sql
STABLE
AS $$
    SELECT current_setting('request.headers', true)::json ->> header_name
$$;

-- Helper function to get client IP from X-Forwarded-For header
CREATE OR REPLACE FUNCTION public.get_client_ip()
RETURNS inet
LANGUAGE sql
STABLE
AS $$
    SELECT NULLIF(
        SPLIT_PART(COALESCE(public.get_request_header('x-forwarded-for'), ''), ',', 1),
        ''
    )::inet
$$;

-- Audit log table
CREATE TABLE public.audit_log (
    id BIGSERIAL PRIMARY KEY,
    table_name TEXT NOT NULL,
    record_id TEXT NOT NULL,
    action TEXT NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE')),
    old_data JSONB,
    new_data JSONB,
    changed_fields TEXT[], -- For UPDATE, list of changed columns
    changed_by UUID REFERENCES auth.users(id),
    changed_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    client_ip INET,
    user_agent TEXT,
    session_id TEXT -- From JWT for session tracking
);

-- Indexes for common audit queries
CREATE INDEX idx_audit_log_table_record ON public.audit_log(table_name, record_id);
CREATE INDEX idx_audit_log_changed_by ON public.audit_log(changed_by);
CREATE INDEX idx_audit_log_changed_at ON public.audit_log(changed_at DESC);
CREATE INDEX idx_audit_log_action ON public.audit_log(action);

-- Partition by month for better performance (optional, can add later)
-- For now, simple table is sufficient for MVP

-- Enable RLS - APPEND-ONLY: No UPDATE, No DELETE
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

-- Allow inserts (triggers run as SECURITY DEFINER)
CREATE POLICY "Allow system inserts" ON public.audit_log
FOR INSERT
WITH CHECK (true);

-- Only admins can read audit log
CREATE POLICY "Admins can read audit log" ON public.audit_log
FOR SELECT
TO authenticated
USING (public.get_user_role() = 'admin');

-- NO UPDATE policy = cannot modify audit entries
-- NO DELETE policy = cannot delete audit entries

-- Generic audit trigger function
CREATE OR REPLACE FUNCTION public.audit_trigger_func()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    record_pk text;
    changed_cols text[];
    old_val jsonb;
    new_val jsonb;
    col_name text;
BEGIN
    -- Get primary key value (assumes 'id' column exists)
    IF TG_OP = 'DELETE' THEN
        record_pk := OLD.id::text;
    ELSE
        record_pk := NEW.id::text;
    END IF;

    -- For UPDATE, compute changed fields
    IF TG_OP = 'UPDATE' THEN
        old_val := to_jsonb(OLD);
        new_val := to_jsonb(NEW);

        FOR col_name IN SELECT key FROM jsonb_object_keys(new_val) AS key
        LOOP
            IF old_val -> col_name IS DISTINCT FROM new_val -> col_name THEN
                changed_cols := array_append(changed_cols, col_name);
            END IF;
        END LOOP;
    END IF;

    INSERT INTO public.audit_log (
        table_name,
        record_id,
        action,
        old_data,
        new_data,
        changed_fields,
        changed_by,
        client_ip,
        user_agent,
        session_id
    ) VALUES (
        TG_TABLE_NAME,
        record_pk,
        TG_OP,
        CASE WHEN TG_OP IN ('UPDATE', 'DELETE') THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN to_jsonb(NEW) ELSE NULL END,
        changed_cols,
        auth.uid(),
        public.get_client_ip(),
        public.get_request_header('user-agent'),
        (auth.jwt() ->> 'session_id')
    );

    IF TG_OP = 'DELETE' THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$;

-- Convenience function to add audit trigger to any table
CREATE OR REPLACE FUNCTION public.enable_audit_for_table(target_table regclass)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    trigger_name text;
BEGIN
    trigger_name := 'tr_audit_' || target_table::text;

    EXECUTE format(
        'CREATE TRIGGER %I
         AFTER INSERT OR UPDATE OR DELETE ON %s
         FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_func()',
        trigger_name,
        target_table
    );
END;
$$;

-- Grant execute to service role only (not public)
REVOKE EXECUTE ON FUNCTION public.enable_audit_for_table FROM PUBLIC;
```

NOTE: We don't apply audit trigger to user_roles yet - that will happen when we have users. Triggers will be applied to business tables (patients, appointments, payments) as they are created in later phases.
  </action>
  <verify>
    - File exists at supabase/migrations/002_audit_infrastructure.sql
    - Contains CREATE TABLE public.audit_log
    - Contains audit_trigger_func()
    - RLS enabled with append-only pattern (no UPDATE/DELETE policies)
    - Admin-only SELECT policy
  </verify>
  <done>Audit log infrastructure created with immutable append-only RLS pattern</done>
</task>

<task type="auto">
  <name>Task 3: Create custom access token hook</name>
  <files>supabase/migrations/003_custom_access_token_hook.sql</files>
  <action>
Create SQL migration for JWT role injection:

```sql
-- Migration: 003_custom_access_token_hook.sql
-- Purpose: Inject user role into JWT claims at token issuance

-- Custom Access Token Hook function
-- This runs every time a JWT is issued (sign-in, refresh)
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    claims jsonb;
    user_role_value text;
BEGIN
    -- Get user's role from user_roles table
    SELECT role::text INTO user_role_value
    FROM public.user_roles
    WHERE user_id = (event->>'user_id')::uuid;

    -- Get existing claims
    claims := event->'claims';

    -- Ensure app_metadata exists
    IF claims->'app_metadata' IS NULL THEN
        claims := jsonb_set(claims, '{app_metadata}', '{}'::jsonb);
    END IF;

    -- Add role to app_metadata in claims
    IF user_role_value IS NOT NULL THEN
        claims := jsonb_set(
            claims,
            '{app_metadata, role}',
            to_jsonb(user_role_value)
        );
    ELSE
        -- No role assigned = 'none' (will fail RLS checks)
        claims := jsonb_set(
            claims,
            '{app_metadata, role}',
            '"none"'::jsonb
        );
    END IF;

    -- Return modified event with updated claims
    RETURN jsonb_set(event, '{claims}', claims);
END;
$$;

-- Grant execute to supabase_auth_admin (required for hook)
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;

-- Revoke from others for security
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM anon;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated;

-- IMPORTANT: After applying this migration, you must enable the hook in Supabase Dashboard:
-- 1. Go to Authentication -> Hooks
-- 2. Enable "Custom Access Token" hook
-- 3. Set function to: public.custom_access_token_hook
--
-- Users must sign out and sign back in to get the updated JWT with role claim.
```

This hook reads from user_roles table and injects the role into the JWT's app_metadata.role claim. RLS policies then use get_user_role() to read this claim.
  </action>
  <verify>
    - File exists at supabase/migrations/003_custom_access_token_hook.sql
    - Contains custom_access_token_hook function
    - Function granted to supabase_auth_admin
    - Function revoked from public, anon, authenticated
  </verify>
  <done>Custom access token hook created for JWT role injection</done>
</task>

</tasks>

<verification>
1. All three migration files exist in supabase/migrations/
2. Each file is valid SQL (no syntax errors)
3. RLS is enabled on both tables
4. get_user_role() extracts from JWT claims
5. audit_log has no UPDATE or DELETE policies (immutable)
6. custom_access_token_hook queries user_roles table
</verification>

<success_criteria>
- Three SQL migration files ready to apply to Supabase
- user_roles table with admin-only RLS
- audit_log table with append-only RLS
- get_user_role() helper function for RLS policies
- custom_access_token_hook for JWT role injection
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-02-SUMMARY.md`
</output>
