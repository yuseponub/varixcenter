---
phase: 11-sales-core
plan: 05
type: execute
wave: 3
depends_on: ["11-03", "11-04"]
files_modified:
  - src/lib/queries/medias/sales.ts
  - src/app/(protected)/medias/ventas/actions.ts
autonomous: true

must_haves:
  truths:
    - "Server actions call RPC functions for atomic operations"
    - "Queries fetch sales with items, methods, and relations"
    - "Error messages are in Spanish for Colombian users"
  artifacts:
    - path: "src/lib/queries/medias/sales.ts"
      provides: "Sale query functions"
      exports: ["getSales", "getSaleById", "getActiveSaleProducts"]
    - path: "src/app/(protected)/medias/ventas/actions.ts"
      provides: "Server actions for sales"
      exports: ["createMediasSale", "deleteMediasSale"]
  key_links:
    - from: "actions.ts"
      to: "create_medias_sale RPC"
      via: "supabase.rpc"
      pattern: "rpc\\('create_medias_sale'"
---

<objective>
Create Supabase query functions and server actions for sales

Purpose: Implement data access layer following payments pattern
Output: Query functions and server actions with proper validation and error handling
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-sales-core/11-RESEARCH.md
@src/app/(protected)/pagos/actions.ts
@src/lib/queries/medias/products.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sales query functions</name>
  <files>src/lib/queries/medias/sales.ts</files>
  <action>
Create query functions following products.ts pattern:

```typescript
import { createClient } from '@/lib/supabase/server'
import type {
  MediasSale,
  MediasSaleWithDetails,
  MediasSaleItem,
  MediasSaleMethod,
} from '@/types/medias/sales'

/**
 * Get all sales with optional filters
 */
export async function getSales(options?: {
  status?: 'activo' | 'anulado'
  limit?: number
  offset?: number
  startDate?: string
  endDate?: string
}): Promise<MediasSaleWithDetails[]> {
  const supabase = await createClient()

  let query = supabase
    .from('medias_sales')
    .select(`
      *,
      items:medias_sale_items(*),
      methods:medias_sale_methods(*),
      patient:patients(id, nombre_completo, cedula)
    `)
    .order('created_at', { ascending: false })

  if (options?.status) {
    query = query.eq('estado', options.status)
  }

  if (options?.startDate) {
    query = query.gte('created_at', options.startDate)
  }

  if (options?.endDate) {
    query = query.lte('created_at', options.endDate)
  }

  if (options?.limit) {
    query = query.limit(options.limit)
  }

  if (options?.offset) {
    query = query.range(options.offset, options.offset + (options.limit || 50) - 1)
  }

  const { data, error } = await query

  if (error) throw error
  return (data || []) as MediasSaleWithDetails[]
}

/**
 * Get single sale by ID with all relations
 */
export async function getSaleById(id: string): Promise<MediasSaleWithDetails | null> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('medias_sales')
    .select(`
      *,
      items:medias_sale_items(*),
      methods:medias_sale_methods(*),
      patient:patients(id, nombre_completo, cedula)
    `)
    .eq('id', id)
    .single()

  if (error) {
    if (error.code === 'PGRST116') return null // Not found
    throw error
  }

  return data as MediasSaleWithDetails
}

/**
 * Get active products with stock for sale form
 */
export async function getActiveSaleProducts() {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('medias_products')
    .select('id, tipo, talla, codigo, precio, stock_normal, stock_devoluciones, activo')
    .eq('activo', true)
    .gt('stock_normal', 0)  // Only products with available stock
    .order('tipo')
    .order('talla')

  if (error) throw error
  return data || []
}

/**
 * Get sales for today (for cash closing)
 */
export async function getTodaySales(): Promise<MediasSaleWithDetails[]> {
  const today = new Date()
  today.setHours(0, 0, 0, 0)
  const tomorrow = new Date(today)
  tomorrow.setDate(tomorrow.getDate() + 1)

  return getSales({
    startDate: today.toISOString(),
    endDate: tomorrow.toISOString(),
    status: 'activo'
  })
}

/**
 * Get sales count and totals for a date range
 */
export async function getSalesSummary(startDate: string, endDate: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('medias_sales')
    .select('total, estado')
    .eq('estado', 'activo')
    .gte('created_at', startDate)
    .lte('created_at', endDate)

  if (error) throw error

  const sales = data || []
  return {
    count: sales.length,
    total: sales.reduce((sum, s) => sum + Number(s.total), 0)
  }
}
```
  </action>
  <verify>
Run: `grep "medias_sales" src/lib/queries/medias/sales.ts` confirms table queries
Run: TypeScript: `npx tsc --noEmit src/lib/queries/medias/sales.ts` passes
  </verify>
  <done>
Query functions provide all needed data access patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sales server actions</name>
  <files>src/app/(protected)/medias/ventas/actions.ts</files>
  <action>
Create server actions following pagos/actions.ts pattern:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { mediasSaleSchema, deleteSaleSchema } from '@/lib/validations/medias/sale'
import { revalidatePath } from 'next/cache'

/**
 * Action state for sale server actions
 */
export type SaleActionState = {
  error?: string
  errors?: Record<string, string[]>
  success?: boolean
  data?: { id: string; numero_venta: string; total: number }
}

/**
 * Create a new medias sale
 *
 * Uses RPC function for atomic transaction with stock decrement
 * Validates with Zod schema before calling database RPC
 */
export async function createMediasSale(
  prevState: SaleActionState | null,
  formData: FormData
): Promise<SaleActionState> {
  const supabase = await createClient()

  // Verify user is authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autorizado. Por favor inicie sesion.' }
  }

  // Parse form data
  let items, methods
  try {
    items = JSON.parse((formData.get('items') as string) || '[]')
    methods = JSON.parse((formData.get('methods') as string) || '[]')
  } catch {
    return { error: 'Datos de formulario invalidos' }
  }

  const rawData = {
    items,
    methods,
    patient_id: (formData.get('patient_id') as string) || null,
    receptor_efectivo_id: (formData.get('receptor_efectivo_id') as string) || null,
  }

  // Validate with Zod
  const validated = mediasSaleSchema.safeParse(rawData)
  if (!validated.success) {
    return {
      errors: validated.error.flatten().fieldErrors as Record<string, string[]>,
      error: 'Por favor corrija los errores en el formulario',
    }
  }

  // Call RPC function for atomic creation
  const { data: saleData, error: saleError } = await supabase.rpc('create_medias_sale', {
    p_items: validated.data.items,
    p_methods: validated.data.methods,
    p_patient_id: validated.data.patient_id || null,
    p_vendedor_id: user.id,
    p_receptor_efectivo_id: validated.data.receptor_efectivo_id || null,
  })

  if (saleError) {
    console.error('Sale creation error:', saleError)

    // Map database errors to Spanish messages
    if (saleError.message.includes('Stock insuficiente')) {
      return { error: saleError.message }
    }
    if (saleError.message.includes('comprobante')) {
      return { error: 'Los pagos electronicos requieren foto del comprobante' }
    }
    if (saleError.message.includes('no encontrado') || saleError.message.includes('no disponible')) {
      return { error: saleError.message }
    }

    return { error: 'Error al crear la venta. Por favor intente de nuevo.' }
  }

  // Revalidate affected pages
  revalidatePath('/medias/ventas')
  revalidatePath('/medias/productos')

  return {
    success: true,
    data: saleData as { id: string; numero_venta: string; total: number },
  }
}

/**
 * Delete (anular) a sale - Admin only
 *
 * Requires admin role (enforced by RPC)
 * Stock is reversed automatically
 */
export async function deleteMediasSale(
  prevState: SaleActionState | null,
  formData: FormData
): Promise<SaleActionState> {
  const supabase = await createClient()

  // Verify user is authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autorizado. Por favor inicie sesion.' }
  }

  const rawData = {
    sale_id: formData.get('sale_id') as string,
    justificacion: formData.get('justificacion') as string,
  }

  // Validate with Zod
  const validated = deleteSaleSchema.safeParse(rawData)
  if (!validated.success) {
    return {
      errors: validated.error.flatten().fieldErrors as Record<string, string[]>,
      error: 'La justificacion debe tener al menos 10 caracteres',
    }
  }

  // Call RPC (validates admin role internally)
  const { error } = await supabase.rpc('eliminar_medias_sale', {
    p_sale_id: validated.data.sale_id,
    p_justificacion: validated.data.justificacion,
  })

  if (error) {
    console.error('Delete sale error:', error)

    if (error.message.includes('Solo Admin')) {
      return { error: 'Solo Admin puede eliminar ventas' }
    }
    if (error.message.includes('10 caracteres')) {
      return { error: 'La justificacion debe tener al menos 10 caracteres' }
    }
    if (error.message.includes('no encontrado')) {
      return { error: 'Venta no encontrada' }
    }

    return { error: 'Error al eliminar la venta' }
  }

  // Revalidate affected pages
  revalidatePath('/medias/ventas')
  revalidatePath('/medias/productos')

  return { success: true }
}
```
  </action>
  <verify>
Run: `grep "rpc('create_medias_sale'" src/app/(protected)/medias/ventas/actions.ts` confirms RPC call
Run: `grep "rpc('eliminar_medias_sale'" src/app/(protected)/medias/ventas/actions.ts` confirms delete RPC
  </verify>
  <done>
Server actions wrap RPC calls with validation and error handling
  </done>
</task>

</tasks>

<verification>
- [ ] getSales fetches with items, methods, and patient relations
- [ ] getSaleById returns single sale with all details
- [ ] getActiveSaleProducts filters by activo=true and stock_normal > 0
- [ ] createMediasSale validates with Zod then calls RPC
- [ ] deleteMediasSale validates admin role via RPC
- [ ] All error messages are in Spanish
- [ ] revalidatePath called for /medias/ventas and /medias/productos
</verification>

<success_criteria>
Query functions and server actions complete, ready for UI components
</success_criteria>

<output>
After completion, create `.planning/phases/11-sales-core/11-05-SUMMARY.md`
</output>
