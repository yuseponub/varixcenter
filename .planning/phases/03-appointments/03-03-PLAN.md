---
phase: 03-appointments
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/queries/appointments.ts
  - supabase/migrations/003_appointments.sql
autonomous: true

must_haves:
  truths:
    - "Appointments can be fetched for calendar view with date range filter"
    - "Appointments can be filtered by doctor (APT-02)"
    - "Query returns data in FullCalendar event format"
    - "Doctors list can be fetched without service role"
  artifacts:
    - path: "src/lib/queries/appointments.ts"
      provides: "Supabase query functions"
      exports: ["getAppointmentsForCalendar", "getAppointmentById", "getDoctors"]
  key_links:
    - from: "src/lib/queries/appointments.ts"
      to: "supabase client"
      via: "import"
      pattern: "createClient.*supabase/server"
    - from: "src/lib/queries/appointments.ts"
      to: "appointments table"
      via: "supabase query"
      pattern: "from\\('appointments'\\)"
---

<objective>
Create Supabase query functions for appointments including calendar view, single appointment fetch, and doctor list via database view.

Purpose: Provide the data access layer that server components and actions will use to fetch appointment data.
Output: Query functions that return typed data with patient and doctor relations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-appointments/03-RESEARCH.md
@src/lib/queries/patients.ts
@src/types/appointments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add doctors view to migration</name>
  <files>supabase/migrations/003_appointments.sql</files>
  <action>
Append to the existing `supabase/migrations/003_appointments.sql` file (add after the GRANT statement):

```sql
-- =============================================================================
-- DOCTORS VIEW
-- Provides access to doctor names without requiring service role
-- Joins user_roles with auth.users via raw_user_meta_data
-- =============================================================================

-- Create a view that joins medico roles with their names
-- This avoids needing auth.admin functions in queries
CREATE OR REPLACE VIEW public.doctors_view AS
SELECT
  ur.user_id as id,
  COALESCE(
    (SELECT raw_user_meta_data->>'nombre' FROM auth.users WHERE id = ur.user_id),
    (SELECT raw_user_meta_data->>'full_name' FROM auth.users WHERE id = ur.user_id),
    (SELECT split_part(email, '@', 1) FROM auth.users WHERE id = ur.user_id),
    'Doctor'
  ) as nombre
FROM public.user_roles ur
WHERE ur.role = 'medico';

-- Grant SELECT on view to authenticated users
GRANT SELECT ON public.doctors_view TO authenticated;

-- RLS not applicable to views - they inherit underlying table permissions
-- The user_roles table already has RLS, so access is controlled there
```

This view:
- Joins user_roles (role='medico') with auth.users
- Extracts nombre from raw_user_meta_data with fallbacks
- Avoids needing supabase.auth.admin.getUserById() which requires service role
- Works with the normal authenticated client
  </action>
  <verify>
- Migration file contains `CREATE OR REPLACE VIEW public.doctors_view`
- View selects from user_roles WHERE role = 'medico'
- GRANT SELECT on doctors_view to authenticated
  </verify>
  <done>doctors_view created allowing doctor queries without service role</done>
</task>

<task type="auto">
  <name>Task 2: Create appointment query functions</name>
  <files>src/lib/queries/appointments.ts</files>
  <action>
Create `src/lib/queries/appointments.ts` following the pattern from patients.ts:

```typescript
import { createClient } from '@/lib/supabase/server'
import {
  CalendarEvent,
  AppointmentWithPatient,
  AppointmentWithRelations,
  Doctor,
  AppointmentStatus
} from '@/types/appointments'
import { STATUS_HEX_COLORS } from '@/lib/appointments/state-machine'

/**
 * Get appointments for calendar view within a date range
 *
 * Used by: Calendar page, main agenda view
 * Returns: FullCalendar-compatible events
 *
 * @param startDate - ISO date string (start of visible range)
 * @param endDate - ISO date string (end of visible range)
 * @param doctorId - Optional filter by doctor (APT-02)
 */
export async function getAppointmentsForCalendar(
  startDate: string,
  endDate: string,
  doctorId?: string | null
): Promise<CalendarEvent[]> {
  const supabase = await createClient()

  let query = supabase
    .from('appointments')
    .select(`
      id,
      fecha_hora_inicio,
      fecha_hora_fin,
      estado,
      notas,
      doctor_id,
      patient:patients!patient_id (
        id,
        nombre,
        apellido
      )
    `)
    .gte('fecha_hora_inicio', startDate)
    .lte('fecha_hora_inicio', endDate)
    .order('fecha_hora_inicio', { ascending: true })

  // APT-02: Filter by doctor if specified
  if (doctorId) {
    query = query.eq('doctor_id', doctorId)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching appointments:', error)
    throw error
  }

  // Transform to FullCalendar event format
  return (data || []).map((apt) => ({
    id: apt.id,
    title: `${apt.patient.nombre} ${apt.patient.apellido}`,
    start: apt.fecha_hora_inicio,
    end: apt.fecha_hora_fin,
    backgroundColor: STATUS_HEX_COLORS[apt.estado as AppointmentStatus],
    borderColor: STATUS_HEX_COLORS[apt.estado as AppointmentStatus],
    extendedProps: {
      patientId: apt.patient.id,
      patientName: `${apt.patient.nombre} ${apt.patient.apellido}`,
      doctorId: apt.doctor_id,
      doctorName: '', // Will be enriched by getDoctorName if needed
      status: apt.estado as AppointmentStatus,
      notas: apt.notas
    }
  }))
}

/**
 * Get a single appointment by ID with full relations
 *
 * Used by: Appointment detail view, edit dialog
 * Note: Uses doctors_view to get doctor name without service role
 */
export async function getAppointmentById(
  appointmentId: string
): Promise<AppointmentWithRelations | null> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('appointments')
    .select(`
      *,
      patient:patients!patient_id (
        id,
        nombre,
        apellido,
        cedula,
        celular
      )
    `)
    .eq('id', appointmentId)
    .single()

  if (error) {
    if (error.code === 'PGRST116') {
      return null // Not found
    }
    console.error('Error fetching appointment:', error)
    throw error
  }

  // Fetch doctor name from doctors_view (no service role needed)
  const { data: doctorData } = await supabase
    .from('doctors_view')
    .select('nombre')
    .eq('id', data.doctor_id)
    .single()

  return {
    ...data,
    patient: data.patient,
    doctor: {
      id: data.doctor_id,
      nombre: doctorData?.nombre || 'Medico'
    }
  } as AppointmentWithRelations
}

/**
 * Get list of doctors for filter dropdown (APT-02)
 *
 * Uses doctors_view which joins user_roles with auth.users
 * No service role required - works with normal authenticated client
 */
export async function getDoctors(): Promise<Doctor[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('doctors_view')
    .select('id, nombre')
    .order('nombre', { ascending: true })

  if (error) {
    console.error('Error fetching doctors:', error)
    throw error
  }

  return data || []
}

/**
 * Get appointments for a specific patient (for timeline)
 *
 * Used by: Patient detail page timeline
 */
export async function getAppointmentsByPatient(
  patientId: string
): Promise<AppointmentWithPatient[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('appointments')
    .select(`
      *,
      patient:patients!patient_id (
        id,
        nombre,
        apellido,
        cedula,
        celular
      )
    `)
    .eq('patient_id', patientId)
    .order('fecha_hora_inicio', { ascending: false })

  if (error) {
    console.error('Error fetching patient appointments:', error)
    throw error
  }

  return data as AppointmentWithPatient[]
}

/**
 * Count appointments for a date (for quick stats)
 */
export async function countAppointmentsForDate(
  date: string,
  doctorId?: string
): Promise<number> {
  const supabase = await createClient()

  // Start and end of the given date
  const startOfDay = `${date}T00:00:00`
  const endOfDay = `${date}T23:59:59`

  let query = supabase
    .from('appointments')
    .select('id', { count: 'exact', head: true })
    .gte('fecha_hora_inicio', startOfDay)
    .lte('fecha_hora_inicio', endOfDay)
    .not('estado', 'in', '(cancelada,no_asistio)')

  if (doctorId) {
    query = query.eq('doctor_id', doctorId)
  }

  const { count, error } = await query

  if (error) {
    console.error('Error counting appointments:', error)
    return 0
  }

  return count || 0
}
```
  </action>
  <verify>
- File exists at `src/lib/queries/appointments.ts`
- `npm run build` passes
- Functions getAppointmentsForCalendar, getAppointmentById, getDoctors are exported
- getDoctors uses doctors_view, not auth.admin
  </verify>
  <done>
- getAppointmentsForCalendar returns FullCalendar-formatted events with date range and doctor filter
- getAppointmentById returns full appointment with patient and doctor relations (via doctors_view)
- getDoctors returns list for APT-02 filter dropdown (via doctors_view, no service role)
- getAppointmentsByPatient ready for patient timeline integration
- countAppointmentsForDate ready for quick stats display
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. All query functions are exported
3. getAppointmentsForCalendar accepts doctorId parameter (APT-02)
4. getDoctors uses doctors_view instead of auth.admin
5. CalendarEvent format matches FullCalendar requirements
</verification>

<success_criteria>
- Date range filtering works for calendar view
- Doctor filtering works for APT-02 requirement
- Patient relation joined for display names
- Doctor names accessible without service role (via doctors_view)
- TypeScript types match return values
- Error handling follows existing patterns
</success_criteria>

<output>
After completion, create `.planning/phases/03-appointments/03-03-SUMMARY.md`
</output>
