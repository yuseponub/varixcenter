---
phase: 04-payments-core
plan: 08
type: execute
wave: 3
depends_on: ["04-04", "04-05", "04-06"]
files_modified:
  - src/app/(protected)/pagos/actions.ts
  - supabase/migrations/012_create_payment_rpc.sql
autonomous: true

must_haves:
  truths:
    - "Payment creation uses atomic RPC function"
    - "Invoice number is generated within transaction"
    - "Anulacion calls database RPC with role check"
  artifacts:
    - path: "src/app/(protected)/pagos/actions.ts"
      provides: "Server actions for payment creation and anulacion"
      contains: "createPayment"
    - path: "supabase/migrations/012_create_payment_rpc.sql"
      provides: "Atomic payment creation RPC"
      contains: "create_payment_with_invoice"
  key_links:
    - from: "actions.ts"
      to: "create_payment_with_invoice RPC"
      via: "supabase.rpc call"
      pattern: "rpc.*create_payment_with_invoice"
---

<objective>
Create payment server actions and the RPC function for atomic payment creation.

Purpose: Ensure payments are created atomically with gapless invoice numbers.
Output: Server actions and migration for payment RPC
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-payments-core/04-RESEARCH.md
@.planning/phases/04-payments-core/04-04-SUMMARY.md
@.planning/phases/04-payments-core/04-05-SUMMARY.md

Reference existing patterns:
@src/app/(protected)/citas/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment RPC migration</name>
  <files>supabase/migrations/012_create_payment_rpc.sql</files>
  <action>
Create migration 012_create_payment_rpc.sql with:

```sql
-- Atomic payment creation function
-- Creates payment, items, and methods in single transaction
-- Generates gapless invoice number with row-level locking

CREATE OR REPLACE FUNCTION public.create_payment_with_invoice(
  p_patient_id UUID,
  p_subtotal DECIMAL,
  p_descuento DECIMAL,
  p_descuento_justificacion TEXT,
  p_total DECIMAL,
  p_created_by UUID,
  p_items JSONB,
  p_methods JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_payment_id UUID;
  v_invoice_number TEXT;
  v_item JSONB;
  v_method JSONB;
  v_items_subtotal DECIMAL := 0;
  v_methods_total DECIMAL := 0;
BEGIN
  -- Validate inputs
  IF p_patient_id IS NULL THEN
    RAISE EXCEPTION 'patient_id es requerido';
  END IF;

  IF p_items IS NULL OR jsonb_array_length(p_items) = 0 THEN
    RAISE EXCEPTION 'Debe incluir al menos un servicio';
  END IF;

  IF p_methods IS NULL OR jsonb_array_length(p_methods) = 0 THEN
    RAISE EXCEPTION 'Debe incluir al menos un metodo de pago';
  END IF;

  -- Validate items total matches subtotal
  SELECT COALESCE(SUM((item->>'unit_price')::DECIMAL * (item->>'quantity')::INTEGER), 0)
  INTO v_items_subtotal
  FROM jsonb_array_elements(p_items) AS item;

  IF ABS(v_items_subtotal - p_subtotal) > 0.01 THEN
    RAISE EXCEPTION 'La suma de items (%) no coincide con subtotal (%)', v_items_subtotal, p_subtotal;
  END IF;

  -- Validate methods total matches payment total
  SELECT COALESCE(SUM((method->>'monto')::DECIMAL), 0)
  INTO v_methods_total
  FROM jsonb_array_elements(p_methods) AS method;

  IF ABS(v_methods_total - p_total) > 0.01 THEN
    RAISE EXCEPTION 'La suma de metodos (%) no coincide con total (%)', v_methods_total, p_total;
  END IF;

  -- Validate descuento justification
  IF p_descuento > 0 AND (p_descuento_justificacion IS NULL OR LENGTH(TRIM(p_descuento_justificacion)) < 5) THEN
    RAISE EXCEPTION 'Los descuentos requieren justificacion (minimo 5 caracteres)';
  END IF;

  -- Validate comprobante for electronic payments
  FOR v_method IN SELECT * FROM jsonb_array_elements(p_methods)
  LOOP
    IF v_method->>'metodo' IN ('tarjeta', 'transferencia', 'nequi')
       AND (v_method->>'comprobante_path' IS NULL OR v_method->>'comprobante_path' = '') THEN
      RAISE EXCEPTION 'Los pagos con % requieren foto del comprobante', v_method->>'metodo';
    END IF;
  END LOOP;

  -- Set lock timeout to prevent deadlocks under load
  SET LOCAL lock_timeout = '10s';

  -- Get next invoice number (this locks the counter row)
  v_invoice_number := get_next_invoice_number();

  -- Insert payment record
  INSERT INTO payments (
    patient_id,
    numero_factura,
    subtotal,
    descuento,
    descuento_justificacion,
    total,
    created_by
  ) VALUES (
    p_patient_id,
    v_invoice_number,
    p_subtotal,
    p_descuento,
    NULLIF(TRIM(p_descuento_justificacion), ''),
    p_total,
    p_created_by
  )
  RETURNING id INTO v_payment_id;

  -- Insert payment items
  FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
  LOOP
    INSERT INTO payment_items (
      payment_id,
      service_id,
      service_name,
      unit_price,
      quantity,
      subtotal
    ) VALUES (
      v_payment_id,
      (v_item->>'service_id')::UUID,
      v_item->>'service_name',
      (v_item->>'unit_price')::DECIMAL,
      (v_item->>'quantity')::INTEGER,
      (v_item->>'unit_price')::DECIMAL * (v_item->>'quantity')::INTEGER
    );
  END LOOP;

  -- Insert payment methods
  FOR v_method IN SELECT * FROM jsonb_array_elements(p_methods)
  LOOP
    INSERT INTO payment_methods (
      payment_id,
      metodo,
      monto,
      comprobante_path
    ) VALUES (
      v_payment_id,
      (v_method->>'metodo')::payment_method_type,
      (v_method->>'monto')::DECIMAL,
      NULLIF(v_method->>'comprobante_path', '')
    );
  END LOOP;

  RETURN jsonb_build_object(
    'id', v_payment_id,
    'numero_factura', v_invoice_number
  );
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION public.create_payment_with_invoice TO authenticated;
```
  </action>
  <verify>
```bash
# Check migration has RPC function
grep -E "CREATE.*FUNCTION|create_payment_with_invoice|RETURNS JSONB" supabase/migrations/012_create_payment_rpc.sql
```
  </verify>
  <done>Migration 012 exists with create_payment_with_invoice RPC that validates all inputs, generates gapless invoice number, inserts payment/items/methods atomically</done>
</task>

<task type="auto">
  <name>Task 2: Create payment server actions</name>
  <files>src/app/(protected)/pagos/actions.ts</files>
  <action>
Create src/app/(protected)/pagos/actions.ts with:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { paymentSchema, anulacionSchema } from '@/lib/validations/payment'
import { revalidatePath } from 'next/cache'

export type PaymentActionState = {
  error?: string
  errors?: Record<string, string[]>
  success?: boolean
  data?: { id: string; numero_factura: string }
}

/**
 * Create a new payment
 * Uses RPC function for atomic transaction with gapless invoice
 */
export async function createPayment(
  prevState: PaymentActionState | null,
  formData: FormData
): Promise<PaymentActionState> {
  const supabase = await createClient()

  // Verify user is authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autorizado. Por favor inicie sesion.' }
  }

  // Parse form data (items and methods are JSON strings)
  let items, methods
  try {
    items = JSON.parse(formData.get('items') as string || '[]')
    methods = JSON.parse(formData.get('methods') as string || '[]')
  } catch {
    return { error: 'Datos de formulario invalidos' }
  }

  const rawData = {
    patient_id: formData.get('patient_id') as string,
    items,
    methods,
    descuento: parseFloat(formData.get('descuento') as string || '0'),
    descuento_justificacion: formData.get('descuento_justificacion') as string || null
  }

  // Validate with Zod
  const validated = paymentSchema.safeParse(rawData)
  if (!validated.success) {
    return {
      errors: validated.error.flatten().fieldErrors as Record<string, string[]>,
      error: 'Por favor corrija los errores en el formulario'
    }
  }

  // Calculate totals
  const subtotal = validated.data.items.reduce(
    (sum, item) => sum + item.unit_price * item.quantity,
    0
  )
  const total = subtotal - validated.data.descuento

  // Call RPC function for atomic creation
  const { data: paymentData, error: paymentError } = await supabase
    .rpc('create_payment_with_invoice', {
      p_patient_id: validated.data.patient_id,
      p_subtotal: subtotal,
      p_descuento: validated.data.descuento,
      p_descuento_justificacion: validated.data.descuento_justificacion,
      p_total: total,
      p_created_by: user.id,
      p_items: validated.data.items,
      p_methods: validated.data.methods
    })

  if (paymentError) {
    console.error('Payment creation error:', paymentError)

    // Map database errors to user-friendly messages
    if (paymentError.message.includes('comprobante')) {
      return { error: 'Los pagos electronicos requieren foto del comprobante' }
    }
    if (paymentError.message.includes('justificacion')) {
      return { error: 'Los descuentos requieren justificacion' }
    }
    if (paymentError.message.includes('no coincide')) {
      return { error: paymentError.message }
    }

    return { error: 'Error al crear el pago. Por favor intente de nuevo.' }
  }

  revalidatePath('/pagos')
  revalidatePath('/pacientes')

  return {
    success: true,
    data: paymentData as { id: string; numero_factura: string }
  }
}

/**
 * Anular (void) a payment
 * Requires admin or medico role
 */
export async function anularPayment(
  prevState: PaymentActionState | null,
  formData: FormData
): Promise<PaymentActionState> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autorizado' }
  }

  const rawData = {
    payment_id: formData.get('payment_id') as string,
    justificacion: formData.get('justificacion') as string
  }

  // Validate
  const validated = anulacionSchema.safeParse(rawData)
  if (!validated.success) {
    return {
      errors: validated.error.flatten().fieldErrors as Record<string, string[]>,
      error: 'La justificacion debe tener al menos 10 caracteres'
    }
  }

  // Call anular_pago RPC (validates role internally)
  const { data, error } = await supabase
    .rpc('anular_pago', {
      p_payment_id: validated.data.payment_id,
      p_justificacion: validated.data.justificacion
    })

  if (error) {
    console.error('Anulacion error:', error)

    if (error.message.includes('Solo Admin y Medico')) {
      return { error: 'Solo Admin y Medico pueden anular pagos' }
    }
    if (error.message.includes('ya fue anulado')) {
      return { error: 'El pago ya fue anulado' }
    }
    if (error.message.includes('10 caracteres')) {
      return { error: 'La justificacion debe tener al menos 10 caracteres' }
    }

    return { error: 'Error al anular el pago' }
  }

  revalidatePath('/pagos')
  revalidatePath('/pacientes')

  return { success: true }
}
```
  </action>
  <verify>
```bash
mkdir -p src/app/\(protected\)/pagos
npx tsc --noEmit src/app/\(protected\)/pagos/actions.ts 2>&1 | head -20
```
  </verify>
  <done>src/app/(protected)/pagos/actions.ts exists with createPayment (calls create_payment_with_invoice RPC) and anularPayment (calls anular_pago RPC) with proper error handling</done>
</task>

</tasks>

<verification>
1. Migration 012 creates valid RPC function
2. RPC validates all inputs before processing
3. RPC uses lock_timeout to prevent deadlocks
4. createPayment validates with Zod before calling RPC
5. createPayment returns payment ID and invoice number on success
6. anularPayment calls anular_pago RPC with role check
7. Error messages mapped to Spanish user-friendly text
</verification>

<success_criteria>
- supabase/migrations/012_create_payment_rpc.sql: Atomic RPC with validation
- src/app/(protected)/pagos/actions.ts: createPayment, anularPayment with Zod validation
- Payment creation generates gapless invoice number
- Anulacion validates role and justificacion
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments-core/04-08-SUMMARY.md`
</output>
