---
phase: 13-purchases
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/types/purchases.ts
  - src/lib/validations/purchase.ts
autonomous: true

must_haves:
  truths:
    - "Purchase TypeScript types match database schema"
    - "PurchaseState type has pendiente_recepcion, recibido, anulado"
    - "Zod schemas validate purchase input"
    - "canTransition function enforces state machine"
  artifacts:
    - path: "src/types/purchases.ts"
      provides: "Purchase, PurchaseItem, PurchaseWithDetails types"
      exports: ["Purchase", "PurchaseItem", "PurchaseState", "PURCHASE_STATES"]
    - path: "src/lib/validations/purchase.ts"
      provides: "Zod validation schemas"
      exports: ["purchaseSchema", "purchaseItemSchema"]
  key_links:
    - from: "src/types/purchases.ts"
      to: "src/types/medias/products.ts"
      via: "MediasProductType, MediasProductSize imports"
      pattern: "import.*from.*medias/products"
---

<objective>
Create TypeScript types and Zod validation schemas for purchases

Purpose: Type safety for purchase registration, state transitions, and form validation
Output: Type definitions and Zod schemas matching database schema
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/13-purchases/13-CONTEXT.md
@.planning/phases/13-purchases/13-RESEARCH.md
@src/types/medias/sales.ts
@src/lib/validations/payment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create purchases TypeScript types</name>
  <files>src/types/purchases.ts</files>
  <action>
Create type definitions following the pattern from src/types/medias/sales.ts:

```typescript
/**
 * Purchase Type Definitions
 *
 * Types matching purchases, purchase_items tables
 * Used by: Purchase registration, reception confirmation, purchase list
 */

// Purchase states (two-step flow)
export const PURCHASE_STATES = ['pendiente_recepcion', 'recibido', 'anulado'] as const
export type PurchaseState = typeof PURCHASE_STATES[number]

// State transition rules
const VALID_TRANSITIONS: Record<PurchaseState, PurchaseState[]> = {
  'pendiente_recepcion': ['recibido', 'anulado'],
  'recibido': ['anulado'],  // Only admin with justification
  'anulado': []             // Terminal state
}

export function canTransition(from: PurchaseState, to: PurchaseState): boolean {
  return VALID_TRANSITIONS[from]?.includes(to) ?? false
}

// State labels for UI
export const PURCHASE_STATE_LABELS: Record<PurchaseState, string> = {
  'pendiente_recepcion': 'Pendiente de Recepcion',
  'recibido': 'Recibido',
  'anulado': 'Anulado',
}

// Purchase header (purchases table)
export interface Purchase {
  id: string
  numero_compra: string
  proveedor: string
  fecha_factura: string
  numero_factura: string | null
  total: number
  factura_path: string
  estado: PurchaseState
  notas: string | null
  created_by: string
  recibido_por: string | null
  recibido_at: string | null
  anulado_por: string | null
  anulado_at: string | null
  anulacion_justificacion: string | null
  created_at: string
  updated_at: string
}

// Purchase item with product snapshot
export interface PurchaseItem {
  id: string
  purchase_id: string
  product_id: string
  product_codigo: string
  product_tipo: string
  product_talla: string
  cantidad: number
  costo_unitario: number
  subtotal: number
  created_at: string
}

// Full purchase with items for detail view
export interface PurchaseWithDetails extends Purchase {
  items: PurchaseItem[]
  created_by_user?: { id: string; email: string } | null
  recibido_por_user?: { id: string; email: string } | null
}

// Input types for purchase creation
export interface PurchaseItemInput {
  product_id: string
  cantidad: number
  costo_unitario: number
}

export interface CreatePurchaseInput {
  proveedor: string
  fecha_factura: string
  numero_factura?: string | null
  total: number
  factura_path: string
  notas?: string | null
  items: PurchaseItemInput[]
}

// OCR result from invoice parsing
export interface OCRProductResult {
  descripcion: string
  cantidad: number
  costo_unitario?: number
  codigo_producto?: string
}

export interface OCRInvoiceResult {
  proveedor?: string
  fecha_factura?: string
  numero_factura?: string
  productos: OCRProductResult[]
  total?: number
}

// Matched product for confirmation UI
export interface MatchedProduct {
  ocr_index: number
  product_id: string | null  // null if not matched
  product_codigo: string | null
  cantidad: number
  costo_unitario: number
  matched: boolean
}
```
  </action>
  <verify>
Run: `grep -E "export (interface|type|const|function)" src/types/purchases.ts`
Verify: All required exports present
  </verify>
  <done>
- PURCHASE_STATES const with all three states
- canTransition function for state machine
- Purchase and PurchaseItem interfaces match schema
- PurchaseWithDetails for detail view
- CreatePurchaseInput for form submission
- OCR types for invoice parsing flow
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation schemas</name>
  <files>src/lib/validations/purchase.ts</files>
  <action>
Create Zod schemas following the pattern from src/lib/validations/payment.ts:

```typescript
import { z } from 'zod'
import { PURCHASE_STATES } from '@/types/purchases'

/**
 * Zod validation schemas for purchases
 *
 * Note: Uses Zod v4 API syntax ({ error: } instead of { required_error: })
 */

// Purchase item input validation
export const purchaseItemSchema = z.object({
  product_id: z.string().uuid({ error: 'ID de producto invalido' }),
  cantidad: z.number().int().positive({ error: 'Cantidad debe ser mayor a 0' }),
  costo_unitario: z.number().nonnegative({ error: 'Costo debe ser mayor o igual a 0' }),
})

// Create purchase validation
export const createPurchaseSchema = z.object({
  proveedor: z.string()
    .min(2, { error: 'Proveedor debe tener al menos 2 caracteres' })
    .max(200, { error: 'Proveedor no puede exceder 200 caracteres' }),
  fecha_factura: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, { error: 'Fecha debe estar en formato YYYY-MM-DD' }),
  numero_factura: z.string()
    .max(100, { error: 'Numero de factura no puede exceder 100 caracteres' })
    .optional()
    .nullable(),
  total: z.number().positive({ error: 'Total debe ser mayor a 0' }),
  factura_path: z.string()
    .min(1, { error: 'Foto de factura es obligatoria' }),
  notas: z.string()
    .max(1000, { error: 'Notas no pueden exceder 1000 caracteres' })
    .optional()
    .nullable(),
  items: z.array(purchaseItemSchema)
    .min(1, { error: 'Debe incluir al menos un producto' }),
})

// State validation
export const purchaseStateSchema = z.enum(PURCHASE_STATES)

// Confirm reception input
export const confirmReceptionSchema = z.object({
  purchase_id: z.string().uuid({ error: 'ID de compra invalido' }),
})

// Cancel purchase input (admin only)
export const cancelPurchaseSchema = z.object({
  purchase_id: z.string().uuid({ error: 'ID de compra invalido' }),
  justificacion: z.string()
    .min(10, { error: 'Justificacion debe tener al menos 10 caracteres' }),
})

// Modification request (enfermera)
export const modificationRequestSchema = z.object({
  purchase_id: z.string().uuid({ error: 'ID de compra invalido' }),
  request_type: z.enum(['edicion', 'eliminacion']),
  motivo: z.string()
    .min(10, { error: 'Motivo debe tener al menos 10 caracteres' }),
})

// Filter schema for purchase list
export const purchaseFilterSchema = z.object({
  fecha_desde: z.string().optional(),
  fecha_hasta: z.string().optional(),
  proveedor: z.string().optional(),
  estado: purchaseStateSchema.optional(),
})

// Type exports from schemas
export type CreatePurchaseInput = z.infer<typeof createPurchaseSchema>
export type PurchaseItemInput = z.infer<typeof purchaseItemSchema>
export type ConfirmReceptionInput = z.infer<typeof confirmReceptionSchema>
export type CancelPurchaseInput = z.infer<typeof cancelPurchaseSchema>
export type ModificationRequestInput = z.infer<typeof modificationRequestSchema>
export type PurchaseFilter = z.infer<typeof purchaseFilterSchema>
```
  </action>
  <verify>
Run: `grep -E "export (const|type)" src/lib/validations/purchase.ts`
Verify: All schemas and type exports present
  </verify>
  <done>
- createPurchaseSchema validates all required fields
- factura_path is required (CONTEXT.md: photo obligatoria)
- purchaseItemSchema validates line items
- confirmReceptionSchema for reception confirmation
- cancelPurchaseSchema requires justification
- modificationRequestSchema for enfermera requests
- purchaseFilterSchema for list filtering
  </done>
</task>

</tasks>

<verification>
- [ ] src/types/purchases.ts exports all types and interfaces
- [ ] PURCHASE_STATES includes all three states
- [ ] canTransition function follows state machine rules
- [ ] src/lib/validations/purchase.ts exports all schemas
- [ ] Zod uses v4 API syntax ({ error: } not { required_error: })
- [ ] factura_path is required in createPurchaseSchema
- [ ] items array requires at least one item
</verification>

<success_criteria>
- TypeScript types match database schema exactly
- State machine prevents invalid transitions
- Zod schemas validate all purchase inputs
- OCR types support invoice parsing flow
</success_criteria>

<output>
After completion, create `.planning/phases/13-purchases/13-03-SUMMARY.md`
</output>
