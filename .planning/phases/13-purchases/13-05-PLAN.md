---
phase: 13-purchases
plan: 05
type: execute
wave: 3
depends_on: ["13-01", "13-03"]
files_modified:
  - src/lib/storage/purchases.ts
  - src/lib/queries/purchases.ts
autonomous: true

must_haves:
  truths:
    - "Invoice upload uses signed URL pattern"
    - "getPurchases supports filtering by estado, proveedor, fecha"
    - "getPurchaseById returns purchase with items"
    - "Default order shows pendientes first"
  artifacts:
    - path: "src/lib/storage/purchases.ts"
      provides: "Invoice upload signed URL functions"
      exports: ["createInvoiceUploadUrl"]
    - path: "src/lib/queries/purchases.ts"
      provides: "Purchase database query functions"
      exports: ["getPurchases", "getPurchaseById"]
  key_links:
    - from: "src/lib/queries/purchases.ts"
      to: "src/types/purchases.ts"
      via: "type imports"
      pattern: "import.*from.*@/types/purchases"
---

<objective>
Create storage helpers and database query functions for purchases

Purpose: Reusable functions for invoice upload and purchase data retrieval
Output: Storage helpers following receipts.ts pattern, queries following existing patterns
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/13-purchases/13-CONTEXT.md
@src/lib/storage/receipts.ts
@src/lib/queries/medias-products.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invoice storage helpers</name>
  <files>src/lib/storage/purchases.ts</files>
  <action>
Create storage helpers following the pattern from src/lib/storage/receipts.ts:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'

const BUCKET_NAME = 'payment-receipts'

/**
 * Generate a signed upload URL for purchase invoice (photo or PDF)
 * Client uploads directly to Supabase Storage
 * Valid for 2 hours
 */
export async function createInvoiceUploadUrl(
  fileName: string
): Promise<{ signedUrl: string; path: string } | { error: string }> {
  const supabase = await createClient()

  // Verify user is authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autorizado' }
  }

  // Generate unique path: facturas/{user_id}/{timestamp}_{filename}
  const timestamp = Date.now()
  const safeName = fileName.replace(/[^a-zA-Z0-9.-]/g, '_')
  const path = `facturas/${user.id}/${timestamp}_${safeName}`

  const { data, error } = await supabase.storage
    .from(BUCKET_NAME)
    .createSignedUploadUrl(path)

  if (error) {
    console.error('Failed to create signed URL for invoice:', error)
    return { error: 'Error al generar URL de subida' }
  }

  return {
    signedUrl: data.signedUrl,
    path: path
  }
}

/**
 * Get public URL for an invoice (for viewing)
 */
export async function getInvoicePublicUrl(path: string): Promise<string | null> {
  const supabase = await createClient()

  const { data } = supabase.storage
    .from(BUCKET_NAME)
    .getPublicUrl(path)

  return data.publicUrl
}

/**
 * Get signed URL for invoice viewing (valid for 1 hour)
 * Use this for PDFs that need authentication
 */
export async function getInvoiceSignedUrl(path: string): Promise<string | null> {
  const supabase = await createClient()

  const { data, error } = await supabase.storage
    .from(BUCKET_NAME)
    .createSignedUrl(path, 3600) // 1 hour

  if (error) {
    console.error('Failed to get invoice signed URL:', error)
    return null
  }

  return data.signedUrl
}
```
  </action>
  <verify>
Run: `grep -E "export async function" src/lib/storage/purchases.ts`
Verify: createInvoiceUploadUrl, getInvoicePublicUrl, getInvoiceSignedUrl exported
  </verify>
  <done>
- createInvoiceUploadUrl generates signed upload URL
- Uses facturas/ subfolder in payment-receipts bucket
- getInvoicePublicUrl and getInvoiceSignedUrl for viewing
- Follows exact pattern from receipts.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create purchase query functions</name>
  <files>src/lib/queries/purchases.ts</files>
  <action>
Create query functions following existing patterns:

```typescript
import { createClient } from '@/lib/supabase/server'
import type {
  Purchase,
  PurchaseWithDetails,
  PurchaseState,
} from '@/types/purchases'

/**
 * Get purchases with optional filtering
 *
 * @param options - Filter and pagination options
 * @returns Array of purchases
 */
export async function getPurchases(options: {
  estado?: PurchaseState
  proveedor?: string
  fecha_desde?: string
  fecha_hasta?: string
  limit?: number
  offset?: number
} = {}): Promise<Purchase[]> {
  const supabase = await createClient()

  let query = supabase
    .from('purchases')
    .select('*')
    // Default order: pendientes first, then by created_at DESC
    .order('estado', { ascending: true }) // pendiente_recepcion < recibido < anulado
    .order('created_at', { ascending: false })

  // Apply filters
  if (options.estado) {
    query = query.eq('estado', options.estado)
  }

  if (options.proveedor) {
    query = query.ilike('proveedor', `%${options.proveedor}%`)
  }

  if (options.fecha_desde) {
    query = query.gte('fecha_factura', options.fecha_desde)
  }

  if (options.fecha_hasta) {
    query = query.lte('fecha_factura', options.fecha_hasta)
  }

  // Pagination
  if (options.limit) {
    query = query.limit(options.limit)
  }

  if (options.offset) {
    query = query.range(options.offset, options.offset + (options.limit || 50) - 1)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching purchases:', error)
    throw new Error('Error al cargar compras')
  }

  return data as Purchase[]
}

/**
 * Get single purchase with items and user details
 *
 * @param id - Purchase UUID
 * @returns Purchase with items or null if not found
 */
export async function getPurchaseById(id: string): Promise<PurchaseWithDetails | null> {
  const supabase = await createClient()

  // Fetch purchase header
  const { data: purchase, error: purchaseError } = await supabase
    .from('purchases')
    .select('*')
    .eq('id', id)
    .single()

  if (purchaseError || !purchase) {
    if (purchaseError?.code === 'PGRST116') {
      return null // Not found
    }
    console.error('Error fetching purchase:', purchaseError)
    throw new Error('Error al cargar compra')
  }

  // Fetch items
  const { data: items, error: itemsError } = await supabase
    .from('purchase_items')
    .select('*')
    .eq('purchase_id', id)
    .order('created_at', { ascending: true })

  if (itemsError) {
    console.error('Error fetching purchase items:', itemsError)
    throw new Error('Error al cargar items de compra')
  }

  // Fetch created_by user info if needed
  let created_by_user = null
  if (purchase.created_by) {
    const { data: userData } = await supabase
      .from('auth.users')
      .select('id, email')
      .eq('id', purchase.created_by)
      .single()
    created_by_user = userData
  }

  // Fetch recibido_por user info if exists
  let recibido_por_user = null
  if (purchase.recibido_por) {
    const { data: userData } = await supabase
      .from('auth.users')
      .select('id, email')
      .eq('id', purchase.recibido_por)
      .single()
    recibido_por_user = userData
  }

  return {
    ...purchase,
    items: items || [],
    created_by_user,
    recibido_por_user,
  } as PurchaseWithDetails
}

/**
 * Count purchases by estado (for badges/stats)
 */
export async function countPurchasesByEstado(): Promise<Record<PurchaseState, number>> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('purchases')
    .select('estado')

  if (error) {
    console.error('Error counting purchases:', error)
    return {
      'pendiente_recepcion': 0,
      'recibido': 0,
      'anulado': 0,
    }
  }

  const counts = {
    'pendiente_recepcion': 0,
    'recibido': 0,
    'anulado': 0,
  }

  for (const row of data) {
    if (row.estado in counts) {
      counts[row.estado as PurchaseState]++
    }
  }

  return counts
}

/**
 * Get products for matching OCR results
 * Returns active products with codigo for dropdown
 */
export async function getProductsForMatching(): Promise<Array<{
  id: string
  codigo: string
  tipo: string
  talla: string
  precio: number
}>> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('medias_products')
    .select('id, codigo, tipo, talla, precio')
    .eq('activo', true)
    .order('tipo')
    .order('talla')

  if (error) {
    console.error('Error fetching products for matching:', error)
    return []
  }

  return data || []
}
```
  </action>
  <verify>
Run: `grep -E "export async function" src/lib/queries/purchases.ts`
Verify: getPurchases, getPurchaseById, countPurchasesByEstado, getProductsForMatching exported
  </verify>
  <done>
- getPurchases supports filtering by estado, proveedor, fecha range
- Default order: pendientes first (ascending estado), then created_at DESC
- getPurchaseById returns purchase with items and user details
- countPurchasesByEstado for dashboard badges
- getProductsForMatching for OCR result matching dropdown
  </done>
</task>

</tasks>

<verification>
- [ ] src/lib/storage/purchases.ts exports all storage functions
- [ ] Uses facturas/ subfolder in payment-receipts bucket
- [ ] src/lib/queries/purchases.ts exports all query functions
- [ ] getPurchases default order shows pendientes first
- [ ] getPurchaseById joins items correctly
- [ ] getProductsForMatching returns active products only
</verification>

<success_criteria>
- Invoice uploads stored in facturas/ subfolder
- Purchases queryable with multiple filter options
- Pending purchases appear first in list
- Product matching ready for OCR confirmation flow
</success_criteria>

<output>
After completion, create `.planning/phases/13-purchases/13-05-SUMMARY.md`
</output>
