---
phase: 11-sales-core
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/medias/sales.ts
  - src/lib/validations/medias/sale.ts
autonomous: true

must_haves:
  truths:
    - "Sale types match database schema exactly"
    - "Validation enforces comprobante for electronic payments"
    - "Types exported and ready for use in components"
  artifacts:
    - path: "src/types/medias/sales.ts"
      provides: "MediasSale, MediasSaleItem, MediasSaleMethod types"
      exports: ["MediasSale", "MediasSaleItem", "MediasSaleMethod"]
    - path: "src/lib/validations/medias/sale.ts"
      provides: "Zod schemas for sale form"
      exports: ["mediasSaleSchema", "MediasSaleFormData"]
  key_links:
    - from: "src/types/medias/sales.ts"
      to: "src/types/medias/products.ts"
      via: "type imports"
      pattern: "MediasProductType"
---

<objective>
Create TypeScript types and Zod validation schemas for sales

Purpose: Define type-safe interfaces matching database schema and validation rules
Output: sales.ts types and sale.ts validation following existing patterns
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-sales-core/11-RESEARCH.md
@src/types/medias/products.ts
@src/lib/validations/medias/product.ts
@src/types/payments.ts
@src/lib/validations/payment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sales types</name>
  <files>src/types/medias/sales.ts</files>
  <action>
Create types matching database schema from 021_medias_sales.sql:

```typescript
/**
 * Medias Sales Type Definitions
 *
 * Types matching medias_sales, medias_sale_items, medias_sale_methods tables
 * Used by: Sale creation, sales list, receipt generation
 */

import { MediasProductType, MediasProductSize } from './products'

/**
 * Payment status (reuse from payments domain)
 */
export type SaleStatus = 'activo' | 'anulado'

/**
 * Payment method types (same as clinic payments)
 */
export const PAYMENT_METHODS = ['efectivo', 'tarjeta', 'transferencia', 'nequi'] as const
export type PaymentMethodType = (typeof PAYMENT_METHODS)[number]

export const PAYMENT_METHOD_LABELS: Record<PaymentMethodType, string> = {
  efectivo: 'Efectivo',
  tarjeta: 'Tarjeta',
  transferencia: 'Transferencia',
  nequi: 'Nequi',
}

/**
 * Check if payment method requires comprobante photo
 */
export function requiresComprobante(method: PaymentMethodType): boolean {
  return method !== 'efectivo'
}

/**
 * Sale header (medias_sales table)
 */
export interface MediasSale {
  id: string
  numero_venta: string
  patient_id: string | null
  subtotal: number
  total: number
  estado: SaleStatus
  eliminado_por: string | null
  eliminado_at: string | null
  eliminacion_justificacion: string | null
  vendedor_id: string
  receptor_efectivo_id: string | null
  created_at: string
}

/**
 * Sale item with product snapshot (medias_sale_items table)
 */
export interface MediasSaleItem {
  id: string
  sale_id: string
  product_id: string
  product_codigo: string
  product_tipo: string  // Snapshot as string (from enum)
  product_talla: string // Snapshot as string (from enum)
  unit_price: number
  quantity: number
  subtotal: number
  created_at: string
}

/**
 * Payment method entry (medias_sale_methods table)
 */
export interface MediasSaleMethod {
  id: string
  sale_id: string
  metodo: PaymentMethodType
  monto: number
  comprobante_path: string | null
  created_at: string
}

/**
 * Full sale with items and methods (for detail view)
 */
export interface MediasSaleWithDetails extends MediasSale {
  items: MediasSaleItem[]
  methods: MediasSaleMethod[]
  patient?: {
    id: string
    nombre_completo: string
    cedula: string
  } | null
  vendedor?: {
    id: string
    email: string
  } | null
}

/**
 * Input types for sale creation
 */
export interface MediasSaleItemInput {
  product_id: string
  quantity: number
}

export interface MediasSaleMethodInput {
  metodo: PaymentMethodType
  monto: number
  comprobante_path: string | null
}

/**
 * Cart item with product details (for UI state)
 */
export interface CartItem {
  product_id: string
  codigo: string
  tipo: MediasProductType
  talla: MediasProductSize
  precio: number
  quantity: number
  subtotal: number
  stock_available: number
}
```
  </action>
  <verify>
Run: `grep "MediasSale" src/types/medias/sales.ts` confirms main types exist
Run: `grep "requiresComprobante" src/types/medias/sales.ts` confirms helper function
  </verify>
  <done>
Types file exports all sale-related interfaces matching database schema
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sale validation schemas</name>
  <files>src/lib/validations/medias/sale.ts</files>
  <action>
Create Zod schemas following payment.ts pattern:

```typescript
import { z } from 'zod'
import { PAYMENT_METHODS } from '@/types/medias/sales'

/**
 * Sale item input schema
 */
export const mediasSaleItemSchema = z.object({
  product_id: z.string().uuid('ID de producto invalido'),
  quantity: z.number().int().min(1, 'La cantidad debe ser al menos 1'),
})

/**
 * Payment method schema with comprobante validation (VTA-05)
 * ANTI-FRAUD: Electronic payments require photo proof
 */
export const mediasSaleMethodSchema = z.object({
  metodo: z.enum(PAYMENT_METHODS, { error: 'Metodo de pago invalido' }),
  monto: z.number().positive('El monto debe ser positivo'),
  comprobante_path: z.string().nullable(),
})
.refine(
  data => data.metodo === 'efectivo' || (data.comprobante_path !== null && data.comprobante_path !== ''),
  { message: 'Los pagos electronicos requieren foto del comprobante', path: ['comprobante_path'] }
)

/**
 * Full sale creation schema
 * Used by: Sale form, createMediasSale server action
 */
export const mediasSaleSchema = z.object({
  items: z
    .array(mediasSaleItemSchema)
    .min(1, 'Debe seleccionar al menos un producto'),

  methods: z
    .array(mediasSaleMethodSchema)
    .min(1, 'Debe especificar metodo de pago'),

  patient_id: z.string().uuid().nullable().optional(),

  receptor_efectivo_id: z.string().uuid().nullable().optional(),
})

/**
 * Delete sale schema (admin only)
 * Requires 10+ character justification for audit trail
 */
export const deleteSaleSchema = z.object({
  sale_id: z.string().uuid('ID de venta invalido'),
  justificacion: z
    .string()
    .min(10, 'La justificacion debe tener al menos 10 caracteres')
    .max(500, 'La justificacion es muy larga'),
})

/**
 * TypeScript types inferred from schemas
 */
export type MediasSaleFormData = z.infer<typeof mediasSaleSchema>
export type MediasSaleItemInput = z.infer<typeof mediasSaleItemSchema>
export type MediasSaleMethodInput = z.infer<typeof mediasSaleMethodSchema>
export type DeleteSaleFormData = z.infer<typeof deleteSaleSchema>
```
  </action>
  <verify>
Run: `grep "refine" src/lib/validations/medias/sale.ts` confirms comprobante validation
Run: TypeScript compilation: `npx tsc --noEmit src/lib/validations/medias/sale.ts` passes
  </verify>
  <done>
Validation schemas enforce all business rules including comprobante requirement
  </done>
</task>

</tasks>

<verification>
- [ ] MediasSale interface matches medias_sales table columns
- [ ] MediasSaleItem includes product snapshots (codigo, tipo, talla)
- [ ] MediasSaleMethod includes comprobante_path
- [ ] requiresComprobante() returns true for tarjeta, transferencia, nequi
- [ ] Zod schema refine validates comprobante for electronic methods
- [ ] Delete schema requires 10+ char justification
</verification>

<success_criteria>
Types and validations are complete and type-safe, ready for server actions and components
</success_criteria>

<output>
After completion, create `.planning/phases/11-sales-core/11-04-SUMMARY.md`
</output>
