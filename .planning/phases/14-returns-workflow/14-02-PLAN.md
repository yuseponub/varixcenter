---
phase: 14-returns-workflow
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - supabase/migrations/034_medias_returns_rpc.sql
autonomous: true

must_haves:
  truths:
    - "create_medias_return RPC validates quantity against sale item"
    - "approve_medias_return RPC increments stock_devoluciones (not stock_normal)"
    - "approve_medias_return creates stock movement with tipo='devolucion'"
    - "reject_medias_return RPC changes estado without affecting stock"
    - "Only admin/medico roles can call approve/reject RPCs"
  artifacts:
    - path: "supabase/migrations/034_medias_returns_rpc.sql"
      provides: "RPC functions for return lifecycle"
      min_lines: 250
  key_links:
    - from: "approve_medias_return"
      to: "medias_products.stock_devoluciones"
      via: "UPDATE increment"
      pattern: "stock_devoluciones = stock_devoluciones \\+ v_return.cantidad"
    - from: "approve_medias_return"
      to: "medias_stock_movements"
      via: "INSERT movement"
      pattern: "INSERT INTO.*medias_stock_movements"
---

<objective>
Create RPC functions for return lifecycle: creation (with quantity validation), approval (with stock_devoluciones increment), and rejection.

Purpose: Encapsulates all return business logic in atomic database functions with role validation for fraud prevention.
Output: Migration file 034_medias_returns_rpc.sql with three SECURITY DEFINER functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-returns-workflow/14-CONTEXT.md
@.planning/phases/14-returns-workflow/14-RESEARCH.md
@supabase/migrations/022_medias_sales_immutability.sql
@supabase/migrations/023_create_medias_sale_rpc.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create create_medias_return RPC function</name>
  <files>supabase/migrations/034_medias_returns_rpc.sql</files>
  <action>
Create migration file with create_medias_return function:

```sql
CREATE OR REPLACE FUNCTION public.create_medias_return(
  p_sale_id UUID,
  p_sale_item_id UUID,
  p_cantidad INTEGER,
  p_motivo TEXT,
  p_metodo_reembolso TEXT,
  p_foto_path TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
```

Function logic:
1. **Auth validation:** Get auth.uid(), fail if NULL
2. **Role validation:** Any authenticated user can create (no role restriction)
3. **Fetch sale_item:** Get from medias_sale_items WHERE id = p_sale_item_id AND sale_id = p_sale_id
4. **Validate item exists:** RAISE EXCEPTION if not found
5. **Validate sale is active:** Check medias_sales.estado = 'activo'
6. **Calculate already returned:** SUM(cantidad) from medias_returns WHERE sale_item_id = p_sale_item_id AND estado IN ('pendiente', 'aprobada')
7. **Validate quantity:** p_cantidad <= (sale_item.quantity - already_returned), else RAISE EXCEPTION 'Cantidad excede unidades disponibles para devolucion'
8. **Validate motivo:** LENGTH(TRIM(p_motivo)) >= 10, else RAISE EXCEPTION
9. **Validate metodo_reembolso:** Must be 'efectivo' or 'cambio_producto'
10. **Get next number:** v_numero := get_next_medias_return_number()
11. **Calculate monto:** v_monto := sale_item.unit_price * p_cantidad
12. **INSERT medias_returns** with product snapshot from sale_item
13. **RETURN** jsonb with id, numero_devolucion, monto_devolucion

Include comment explaining the quantity validation logic to prevent over-returns.
  </action>
  <verify>Check function handles edge cases: item not found, sale anulada, quantity exceeds available</verify>
  <done>create_medias_return RPC validates quantity and creates return with DEV- number</done>
</task>

<task type="auto">
  <name>Task 2: Create approve_medias_return RPC function</name>
  <files>supabase/migrations/034_medias_returns_rpc.sql</files>
  <action>
Add approve_medias_return function to the migration:

```sql
CREATE OR REPLACE FUNCTION public.approve_medias_return(
  p_return_id UUID,
  p_notas TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
```

Function logic:
1. **Auth validation:** Get auth.uid()
2. **Role validation:** SELECT role FROM user_roles WHERE user_id = v_user_id; IF v_role NOT IN ('admin', 'medico') THEN RAISE EXCEPTION 'Solo Admin o Medico pueden aprobar devoluciones'
3. **Fetch return:** Get full record from medias_returns WHERE id = p_return_id
4. **Validate exists:** RAISE EXCEPTION if not found
5. **Validate estado:** IF v_return.estado != 'pendiente' THEN RAISE EXCEPTION 'Solo se pueden aprobar devoluciones pendientes'
6. **Get product_id from sale_item:** SELECT product_id FROM medias_sale_items WHERE id = v_return.sale_item_id
7. **Get current stock:** SELECT stock_normal, stock_devoluciones FROM medias_products WHERE id = v_product_id FOR UPDATE
8. **Increment stock_devoluciones:** UPDATE medias_products SET stock_devoluciones = stock_devoluciones + v_return.cantidad WHERE id = v_product_id
9. **Create stock movement:**
   ```sql
   INSERT INTO medias_stock_movements (
     product_id, tipo, cantidad,
     stock_normal_antes, stock_normal_despues,
     stock_devoluciones_antes, stock_devoluciones_despues,
     referencia_id, referencia_tipo, notas, created_by
   ) VALUES (
     v_product_id, 'devolucion', v_return.cantidad,
     v_product.stock_normal, v_product.stock_normal,  -- unchanged
     v_product.stock_devoluciones, v_product.stock_devoluciones + v_return.cantidad,
     p_return_id, 'devolucion', v_return.motivo, v_user_id
   )
   ```
10. **Update return:** SET estado = 'aprobada', aprobador_id = v_user_id, aprobado_at = now(), notas_aprobador = p_notas
11. **RETURN** jsonb with success info

CRITICAL: Stock increment goes to stock_devoluciones, NOT stock_normal (per CONTEXT.md and RESEARCH.md)
  </action>
  <verify>Check stock movement references 'devolucion' as tipo and referencia_tipo</verify>
  <done>approve_medias_return increments stock_devoluciones and creates audit trail</done>
</task>

<task type="auto">
  <name>Task 3: Create reject_medias_return RPC function</name>
  <files>supabase/migrations/034_medias_returns_rpc.sql</files>
  <action>
Add reject_medias_return function:

```sql
CREATE OR REPLACE FUNCTION public.reject_medias_return(
  p_return_id UUID,
  p_notas TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
```

Function logic:
1. **Auth and role validation:** Same as approve (admin/medico only)
2. **Fetch return:** Get record
3. **Validate estado:** Must be 'pendiente'
4. **Update return:** SET estado = 'rechazada', aprobador_id = v_user_id, aprobado_at = now(), notas_aprobador = p_notas
5. **NO stock change** - rejected returns don't affect inventory
6. **RETURN** jsonb with id, numero_devolucion, estado

Add GRANT EXECUTE to authenticated for all three functions.

Add verification block checking all three functions exist.
  </action>
  <verify>Check reject function does NOT touch stock tables</verify>
  <done>reject_medias_return changes estado without stock impact</done>
</task>

</tasks>

<verification>
1. create_medias_return validates: sale exists, sale active, quantity <= available
2. approve_medias_return increments stock_devoluciones (NOT stock_normal)
3. approve_medias_return creates medias_stock_movements with tipo='devolucion'
4. reject_medias_return only changes estado (no stock)
5. Both approve/reject validate admin/medico role via user_roles table
6. All functions return JSONB with relevant data
</verification>

<success_criteria>
- [ ] Migration file 034_medias_returns_rpc.sql created
- [ ] create_medias_return validates quantity against already returned
- [ ] approve_medias_return increments stock_devoluciones
- [ ] approve_medias_return creates stock movement audit record
- [ ] reject_medias_return does NOT touch stock
- [ ] Role validation prevents non-admin/medico from approving
- [ ] All functions have GRANT EXECUTE to authenticated
</success_criteria>

<output>
After completion, create `.planning/phases/14-returns-workflow/14-02-SUMMARY.md`
</output>
