---
phase: 13-purchases
plan: 06
type: execute
wave: 4
depends_on: ["13-02", "13-03", "13-05"]
files_modified:
  - src/app/(protected)/compras/actions.ts
autonomous: true

must_haves:
  truths:
    - "createPurchase server action creates purchase with items"
    - "confirmReception calls RPC to increment stock"
    - "cancelPurchase requires justification and checks role"
    - "requestModification creates alert for enfermera"
  artifacts:
    - path: "src/app/(protected)/compras/actions.ts"
      provides: "Server actions for purchase CRUD"
      exports: ["createPurchase", "confirmReception", "cancelPurchase", "requestModification"]
  key_links:
    - from: "src/app/(protected)/compras/actions.ts"
      to: "confirm_purchase_reception RPC"
      via: "supabase.rpc call"
      pattern: "supabase\\.rpc.*confirm_purchase_reception"
---

<objective>
Create server actions for purchase operations

Purpose: Handle purchase creation, reception confirmation, cancellation, and modification requests
Output: Server actions with proper validation, role checks, and RPC calls
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/13-purchases/13-CONTEXT.md
@src/app/(protected)/citas/actions.ts
@src/app/(protected)/medias/ventas/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create purchase server actions</name>
  <files>src/app/(protected)/compras/actions.ts</files>
  <action>
Create server actions following existing patterns:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import {
  createPurchaseSchema,
  confirmReceptionSchema,
  cancelPurchaseSchema,
  modificationRequestSchema,
  type CreatePurchaseInput,
} from '@/lib/validations/purchase'
import type { PurchaseItemInput } from '@/types/purchases'

/**
 * Get current user's role from JWT
 */
async function getUserRole(supabase: ReturnType<typeof createClient> extends Promise<infer T> ? T : never): Promise<string | null> {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return null
  return user.app_metadata?.role ?? null
}

/**
 * Create a new purchase with items
 * All authenticated users can create purchases (per CONTEXT.md)
 */
export async function createPurchase(input: CreatePurchaseInput): Promise<{
  success: boolean
  purchase_id?: string
  numero_compra?: string
  error?: string
}> {
  const supabase = await createClient()

  // Verify authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autorizado' }
  }

  // Validate input
  const validation = createPurchaseSchema.safeParse(input)
  if (!validation.success) {
    return { success: false, error: validation.error.errors[0]?.message || 'Datos invalidos' }
  }

  const data = validation.data

  try {
    // Get next compra number
    const { data: numeroData, error: numeroError } = await supabase
      .rpc('get_next_compra_number')

    if (numeroError || !numeroData) {
      console.error('Error getting compra number:', numeroError)
      return { success: false, error: 'Error al generar numero de compra' }
    }

    const numero_compra = numeroData as string

    // Create purchase header
    const { data: purchase, error: purchaseError } = await supabase
      .from('purchases')
      .insert({
        numero_compra,
        proveedor: data.proveedor,
        fecha_factura: data.fecha_factura,
        numero_factura: data.numero_factura,
        total: data.total,
        factura_path: data.factura_path,
        notas: data.notas,
        created_by: user.id,
        estado: 'pendiente_recepcion',
      })
      .select('id')
      .single()

    if (purchaseError || !purchase) {
      console.error('Error creating purchase:', purchaseError)
      return { success: false, error: 'Error al crear compra' }
    }

    // Create purchase items with product snapshots
    const itemsToInsert = []
    for (const item of data.items) {
      // Get product snapshot
      const { data: product, error: productError } = await supabase
        .from('medias_products')
        .select('codigo, tipo, talla')
        .eq('id', item.product_id)
        .single()

      if (productError || !product) {
        // Rollback: delete the purchase header
        await supabase.from('purchases').delete().eq('id', purchase.id)
        return { success: false, error: `Producto no encontrado: ${item.product_id}` }
      }

      itemsToInsert.push({
        purchase_id: purchase.id,
        product_id: item.product_id,
        product_codigo: product.codigo,
        product_tipo: product.tipo,
        product_talla: product.talla,
        cantidad: item.cantidad,
        costo_unitario: item.costo_unitario,
        subtotal: item.cantidad * item.costo_unitario,
      })
    }

    const { error: itemsError } = await supabase
      .from('purchase_items')
      .insert(itemsToInsert)

    if (itemsError) {
      // Rollback: delete the purchase header
      await supabase.from('purchases').delete().eq('id', purchase.id)
      console.error('Error creating purchase items:', itemsError)
      return { success: false, error: 'Error al crear items de compra' }
    }

    revalidatePath('/compras')
    return {
      success: true,
      purchase_id: purchase.id,
      numero_compra,
    }
  } catch (error) {
    console.error('Unexpected error creating purchase:', error)
    return { success: false, error: 'Error inesperado' }
  }
}

/**
 * Confirm reception of a purchase
 * Increments stock_normal for all items
 * Any authenticated user can confirm (per CONTEXT.md)
 */
export async function confirmReception(purchase_id: string): Promise<{
  success: boolean
  error?: string
}> {
  const supabase = await createClient()

  // Verify authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autorizado' }
  }

  // Validate input
  const validation = confirmReceptionSchema.safeParse({ purchase_id })
  if (!validation.success) {
    return { success: false, error: 'ID de compra invalido' }
  }

  try {
    // Call RPC for atomic stock increment
    const { data, error } = await supabase.rpc('confirm_purchase_reception', {
      p_purchase_id: purchase_id,
      p_confirmed_by: user.id,
    })

    if (error) {
      console.error('Error confirming reception:', error)
      return { success: false, error: error.message || 'Error al confirmar recepcion' }
    }

    revalidatePath('/compras')
    revalidatePath(`/compras/${purchase_id}`)
    return { success: true }
  } catch (error) {
    console.error('Unexpected error confirming reception:', error)
    return { success: false, error: 'Error inesperado' }
  }
}

/**
 * Cancel (anular) a purchase
 * Admin/Medico can cancel directly
 * Reverses stock if already received
 */
export async function cancelPurchase(
  purchase_id: string,
  justificacion: string
): Promise<{
  success: boolean
  error?: string
}> {
  const supabase = await createClient()

  // Verify authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autorizado' }
  }

  // Check role - only admin/medico can cancel
  const role = await getUserRole(supabase)
  if (!role || !['admin', 'medico'].includes(role)) {
    return { success: false, error: 'Solo Admin o Medico puede anular compras' }
  }

  // Validate input
  const validation = cancelPurchaseSchema.safeParse({ purchase_id, justificacion })
  if (!validation.success) {
    return { success: false, error: validation.error.errors[0]?.message || 'Datos invalidos' }
  }

  try {
    // Get purchase to check current estado
    const { data: purchase, error: purchaseError } = await supabase
      .from('purchases')
      .select('id, estado')
      .eq('id', purchase_id)
      .single()

    if (purchaseError || !purchase) {
      return { success: false, error: 'Compra no encontrada' }
    }

    if (purchase.estado === 'anulado') {
      return { success: false, error: 'La compra ya esta anulada' }
    }

    // If estado = 'recibido', need to reverse stock
    if (purchase.estado === 'recibido') {
      // Get items to reverse stock
      const { data: items, error: itemsError } = await supabase
        .from('purchase_items')
        .select('product_id, cantidad')
        .eq('purchase_id', purchase_id)

      if (itemsError || !items) {
        return { success: false, error: 'Error al obtener items para reversion' }
      }

      // Reverse stock for each item
      for (const item of items) {
        // Get current stock
        const { data: product, error: productError } = await supabase
          .from('medias_products')
          .select('stock_normal, stock_devoluciones')
          .eq('id', item.product_id)
          .single()

        if (productError || !product) {
          return { success: false, error: `Producto no encontrado: ${item.product_id}` }
        }

        // Decrement stock_normal
        const newStockNormal = Math.max(0, product.stock_normal - item.cantidad)

        const { error: updateError } = await supabase
          .from('medias_products')
          .update({ stock_normal: newStockNormal })
          .eq('id', item.product_id)

        if (updateError) {
          return { success: false, error: 'Error al revertir stock' }
        }

        // Log stock movement
        const { error: movementError } = await supabase
          .from('medias_stock_movements')
          .insert({
            product_id: item.product_id,
            tipo: 'ajuste_salida',
            cantidad: item.cantidad,
            stock_normal_antes: product.stock_normal,
            stock_normal_despues: newStockNormal,
            stock_devoluciones_antes: product.stock_devoluciones,
            stock_devoluciones_despues: product.stock_devoluciones,
            referencia_id: purchase_id,
            referencia_tipo: 'anulacion_compra',
            notas: `Anulacion de compra: ${justificacion}`,
            created_by: user.id,
          })

        if (movementError) {
          console.error('Error logging stock movement:', movementError)
          // Continue even if logging fails
        }
      }
    }

    // Update purchase estado
    const { error: updateError } = await supabase
      .from('purchases')
      .update({
        estado: 'anulado',
        anulado_por: user.id,
        anulado_at: new Date().toISOString(),
        anulacion_justificacion: justificacion,
      })
      .eq('id', purchase_id)

    if (updateError) {
      return { success: false, error: 'Error al anular compra' }
    }

    revalidatePath('/compras')
    revalidatePath(`/compras/${purchase_id}`)
    return { success: true }
  } catch (error) {
    console.error('Unexpected error canceling purchase:', error)
    return { success: false, error: 'Error inesperado' }
  }
}

/**
 * Request modification for a purchase (enfermera)
 * Creates an alert for admin/medico approval
 */
export async function requestModification(
  purchase_id: string,
  request_type: 'edicion' | 'eliminacion',
  motivo: string
): Promise<{
  success: boolean
  alert_id?: string
  error?: string
}> {
  const supabase = await createClient()

  // Verify authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autorizado' }
  }

  // Validate input
  const validation = modificationRequestSchema.safeParse({ purchase_id, request_type, motivo })
  if (!validation.success) {
    return { success: false, error: validation.error.errors[0]?.message || 'Datos invalidos' }
  }

  try {
    // Call RPC to create modification request alert
    const { data, error } = await supabase.rpc('create_purchase_modification_request', {
      p_purchase_id: purchase_id,
      p_request_type: request_type,
      p_motivo: motivo,
      p_requested_by: user.id,
    })

    if (error) {
      console.error('Error creating modification request:', error)
      return { success: false, error: error.message || 'Error al crear solicitud' }
    }

    revalidatePath('/compras')
    return {
      success: true,
      alert_id: data as string,
    }
  } catch (error) {
    console.error('Unexpected error requesting modification:', error)
    return { success: false, error: 'Error inesperado' }
  }
}

/**
 * Edit purchase (admin/medico only, or after approval)
 */
export async function editPurchase(
  purchase_id: string,
  updates: {
    proveedor?: string
    fecha_factura?: string
    numero_factura?: string | null
    notas?: string | null
  }
): Promise<{
  success: boolean
  error?: string
}> {
  const supabase = await createClient()

  // Verify authenticated
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, error: 'No autorizado' }
  }

  // Check role - only admin/medico can edit directly
  const role = await getUserRole(supabase)
  if (!role || !['admin', 'medico'].includes(role)) {
    return { success: false, error: 'Solo Admin o Medico puede editar compras' }
  }

  try {
    const { error } = await supabase
      .from('purchases')
      .update(updates)
      .eq('id', purchase_id)

    if (error) {
      console.error('Error editing purchase:', error)
      return { success: false, error: 'Error al editar compra' }
    }

    revalidatePath('/compras')
    revalidatePath(`/compras/${purchase_id}`)
    return { success: true }
  } catch (error) {
    console.error('Unexpected error editing purchase:', error)
    return { success: false, error: 'Error inesperado' }
  }
}
```

Create directory: `mkdir -p src/app/(protected)/compras`
  </action>
  <verify>
Run: `grep -E "export async function" src/app/(protected)/compras/actions.ts`
Verify: All action functions exported
  </verify>
  <done>
- createPurchase creates header + items with product snapshots
- confirmReception calls RPC for atomic stock increment
- cancelPurchase reverses stock if already received, requires admin/medico
- requestModification creates alert for enfermera approval flow
- editPurchase allows admin/medico to edit directly
- All actions have proper validation and error handling
  </done>
</task>

</tasks>

<verification>
- [ ] All server actions marked with 'use server'
- [ ] createPurchase validates input and creates header + items
- [ ] confirmReception calls confirm_purchase_reception RPC
- [ ] cancelPurchase checks role and reverses stock if needed
- [ ] requestModification creates alert via RPC
- [ ] editPurchase checks role before allowing changes
- [ ] All paths revalidated after mutations
</verification>

<success_criteria>
- Purchase CRUD operations work correctly
- Reception confirmation atomically increments stock
- Only admin/medico can cancel or edit directly
- Enfermera uses alert system for modification requests
</success_criteria>

<output>
After completion, create `.planning/phases/13-purchases/13-06-SUMMARY.md`
</output>
