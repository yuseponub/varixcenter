---
phase: 13-purchases
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/ocr/route.ts
  - src/lib/ocr/pdf-to-image.ts
  - package.json
autonomous: true
user_setup:
  - service: openai
    why: "OCR via GPT-4o vision API"
    env_vars:
      - name: OPENAI_API_KEY
        source: "Already configured for transcription API"

must_haves:
  truths:
    - "POST /api/ocr accepts image or PDF and returns parsed invoice data"
    - "PDF files are converted to images before sending to GPT-4o"
    - "Response includes productos array with descripcion and cantidad"
  artifacts:
    - path: "src/app/api/ocr/route.ts"
      provides: "Invoice OCR API endpoint"
      exports: ["POST"]
    - path: "src/lib/ocr/pdf-to-image.ts"
      provides: "PDF to image conversion utility"
      exports: ["pdfToImages"]
  key_links:
    - from: "src/app/api/ocr/route.ts"
      to: "OpenAI API"
      via: "fetch to chat/completions with vision"
      pattern: "api.openai.com.*chat/completions"
---

<objective>
Create OCR API route using GPT-4o vision and PDF conversion utility

Purpose: Parse invoice photos/PDFs to extract products automatically (user confirms before saving)
Output: API route that accepts file, returns structured invoice data
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/13-purchases/13-CONTEXT.md
@.planning/phases/13-purchases/13-RESEARCH.md
@src/app/api/transcribe/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install PDF processing dependencies</name>
  <files>package.json</files>
  <action>
Install pdfjs-dist and canvas for PDF to image conversion:

```bash
npm install pdfjs-dist@^5
npm install @napi-rs/canvas
```

Note: pdfjs-dist v5 is the current stable version with serverless support.
@napi-rs/canvas is the Node.js canvas implementation needed for PDF rendering.
  </action>
  <verify>
Run: `grep -E "(pdfjs-dist|@napi-rs/canvas)" package.json`
Verify: Both dependencies added
  </verify>
  <done>
- pdfjs-dist ^5.x installed
- @napi-rs/canvas installed
- package-lock.json updated
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PDF to image conversion utility</name>
  <files>src/lib/ocr/pdf-to-image.ts</files>
  <action>
Create utility following RESEARCH.md pattern:

```typescript
/**
 * PDF to Image Conversion
 *
 * Converts PDF pages to PNG images for OCR processing.
 * Uses pdfjs-dist for PDF parsing and @napi-rs/canvas for rendering.
 */

import { getDocument, GlobalWorkerOptions, type PDFDocumentProxy } from 'pdfjs-dist'

// Dynamically import canvas to avoid issues in client bundles
const getCanvas = async () => {
  const { createCanvas } = await import('@napi-rs/canvas')
  return createCanvas
}

// Configuration
const DEFAULT_SCALE = 2.0  // Higher = better OCR accuracy
const MAX_PAGES = 5        // Limit for cost control

/**
 * Convert PDF buffer to array of PNG image buffers
 *
 * @param pdfBuffer - ArrayBuffer containing PDF data
 * @param options - Configuration options
 * @returns Array of PNG buffers, one per page
 */
export async function pdfToImages(
  pdfBuffer: ArrayBuffer,
  options: { scale?: number; maxPages?: number } = {}
): Promise<Buffer[]> {
  const { scale = DEFAULT_SCALE, maxPages = MAX_PAGES } = options

  // Load PDF document
  const pdf: PDFDocumentProxy = await getDocument({
    data: new Uint8Array(pdfBuffer),
    // Disable worker for serverless environment
    useWorkerFetch: false,
    isEvalSupported: false,
    useSystemFonts: true,
  }).promise

  const pageCount = Math.min(pdf.numPages, maxPages)
  const images: Buffer[] = []
  const createCanvas = await getCanvas()

  for (let pageNum = 1; pageNum <= pageCount; pageNum++) {
    const page = await pdf.getPage(pageNum)
    const viewport = page.getViewport({ scale })

    // Create canvas for this page
    const canvas = createCanvas(Math.floor(viewport.width), Math.floor(viewport.height))
    const context = canvas.getContext('2d')

    // Render page to canvas
    await page.render({
      canvasContext: context as unknown as CanvasRenderingContext2D,
      viewport,
    }).promise

    // Convert to PNG buffer
    const pngBuffer = canvas.toBuffer('image/png')
    images.push(pngBuffer)

    // Clean up page resources
    page.cleanup()
  }

  // Clean up PDF document
  await pdf.cleanup()

  return images
}

/**
 * Check if a file is a PDF based on magic bytes
 */
export function isPDF(buffer: ArrayBuffer): boolean {
  const header = new Uint8Array(buffer.slice(0, 5))
  // PDF magic bytes: %PDF-
  return (
    header[0] === 0x25 &&
    header[1] === 0x50 &&
    header[2] === 0x44 &&
    header[3] === 0x46 &&
    header[4] === 0x2d
  )
}
```

Create directory: `mkdir -p src/lib/ocr`
  </action>
  <verify>
Run: `cat src/lib/ocr/pdf-to-image.ts | head -50`
Verify: pdfToImages and isPDF functions defined
  </verify>
  <done>
- pdfToImages function converts PDF to PNG buffers
- Uses dynamic import for canvas (serverless compatible)
- MAX_PAGES limit prevents abuse
- isPDF utility for file type detection
  </done>
</task>

<task type="auto">
  <name>Task 3: Create OCR API route</name>
  <files>src/app/api/ocr/route.ts</files>
  <action>
Create API route following the transcribe/route.ts pattern and RESEARCH.md code example:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { isPDF, pdfToImages } from '@/lib/ocr/pdf-to-image'

// Allowed file types
const ALLOWED_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'application/pdf',
]

const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json({ error: 'No se proporciono archivo' }, { status: 400 })
    }

    // Validate file type
    if (!ALLOWED_TYPES.includes(file.type)) {
      return NextResponse.json(
        { error: 'Tipo de archivo no permitido. Use JPG, PNG, WebP o PDF.' },
        { status: 400 }
      )
    }

    // Validate file size
    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { error: 'Archivo muy grande. Maximo 10MB.' },
        { status: 400 }
      )
    }

    const apiKey = process.env.OPENAI_API_KEY
    if (!apiKey) {
      return NextResponse.json(
        { error: 'API key de OpenAI no configurada' },
        { status: 500 }
      )
    }

    // Convert file to base64 (handle PDF conversion)
    const bytes = await file.arrayBuffer()
    let imageBase64: string
    let mimeType: string

    if (file.type === 'application/pdf' || isPDF(bytes)) {
      // Convert PDF to images
      const images = await pdfToImages(bytes, { maxPages: 3 })
      if (images.length === 0) {
        return NextResponse.json(
          { error: 'No se pudo procesar el PDF' },
          { status: 400 }
        )
      }
      // Use first page for OCR (most invoices have items on first page)
      imageBase64 = images[0].toString('base64')
      mimeType = 'image/png'
    } else {
      imageBase64 = Buffer.from(bytes).toString('base64')
      mimeType = file.type
    }

    // Call OpenAI GPT-4o with structured output
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: `Eres un experto en extraer datos de facturas de compra colombianas.
Extrae los productos, cantidades, precios unitarios y datos del proveedor.
Si no puedes leer un campo con certeza, omitelo del resultado.
Los montos estan en pesos colombianos (COP).
Para las cantidades, interpreta "docenas" o "pares" correctamente.`
          },
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: 'Extrae los datos de esta factura de compra de medias de compresion.'
              },
              {
                type: 'image_url',
                image_url: {
                  url: `data:${mimeType};base64,${imageBase64}`,
                  detail: 'high'
                }
              }
            ]
          }
        ],
        response_format: {
          type: 'json_schema',
          json_schema: {
            name: 'invoice_data',
            strict: true,
            schema: {
              type: 'object',
              properties: {
                proveedor: { type: 'string', description: 'Nombre del proveedor' },
                fecha_factura: { type: 'string', description: 'Fecha en formato YYYY-MM-DD' },
                numero_factura: { type: 'string', description: 'Numero de factura' },
                productos: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      descripcion: { type: 'string', description: 'Descripcion del producto' },
                      cantidad: { type: 'number', description: 'Cantidad (unidades)' },
                      costo_unitario: { type: 'number', description: 'Precio unitario en COP' },
                      codigo_producto: { type: 'string', description: 'Codigo del producto si visible' }
                    },
                    required: ['descripcion', 'cantidad'],
                    additionalProperties: false
                  }
                },
                total: { type: 'number', description: 'Total de la factura en COP' }
              },
              required: ['productos'],
              additionalProperties: false
            }
          }
        },
        max_tokens: 4096
      })
    })

    if (!response.ok) {
      const errorText = await response.text()
      console.error('OpenAI API error:', errorText)
      return NextResponse.json(
        { error: 'Error al procesar la factura con OCR' },
        { status: 500 }
      )
    }

    const result = await response.json()
    const content = result.choices[0]?.message?.content

    if (!content) {
      return NextResponse.json(
        { error: 'No se obtuvo respuesta del OCR' },
        { status: 500 }
      )
    }

    // Parse and return the structured data
    const invoiceData = JSON.parse(content)
    return NextResponse.json(invoiceData)

  } catch (error) {
    console.error('OCR processing error:', error)
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    )
  }
}
```

Create directory: `mkdir -p src/app/api/ocr`
  </action>
  <verify>
Run: `cat src/app/api/ocr/route.ts | head -80`
Verify: POST handler with file validation, PDF handling, OpenAI call
  </verify>
  <done>
- POST /api/ocr accepts file via FormData
- Validates file type (image or PDF) and size (10MB max)
- Converts PDF to image using pdfToImages utility
- Calls GPT-4o with structured output schema
- Returns parsed invoice data as JSON
  </done>
</task>

</tasks>

<verification>
- [ ] npm dependencies installed (pdfjs-dist, @napi-rs/canvas)
- [ ] src/lib/ocr/pdf-to-image.ts exports pdfToImages and isPDF
- [ ] src/app/api/ocr/route.ts exports POST handler
- [ ] API validates file type and size
- [ ] PDF files converted to images before OCR
- [ ] Response includes productos array with structured data
</verification>

<success_criteria>
- OCR API accepts both images and PDFs
- GPT-4o extracts products, quantities, costs from invoices
- Structured JSON output ready for user confirmation
- Errors handled gracefully with Spanish messages
</success_criteria>

<output>
After completion, create `.planning/phases/13-purchases/13-04-SUMMARY.md`
</output>
