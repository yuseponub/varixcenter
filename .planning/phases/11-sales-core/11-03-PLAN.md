---
phase: 11-sales-core
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - supabase/migrations/023_create_medias_sale_rpc.sql
autonomous: true

must_haves:
  truths:
    - "Sale creation is atomic (all or nothing)"
    - "Stock is decremented with FOR UPDATE lock preventing race conditions"
    - "Sale blocked if any product has insufficient stock"
  artifacts:
    - path: "supabase/migrations/023_create_medias_sale_rpc.sql"
      provides: "Atomic sale creation RPC"
      contains: "create_medias_sale"
  key_links:
    - from: "create_medias_sale"
      to: "medias_products"
      via: "FOR UPDATE stock lock"
      pattern: "FOR UPDATE"
    - from: "create_medias_sale"
      to: "medias_stock_movements"
      via: "movement logging"
      pattern: "INSERT INTO medias_stock_movements"
---

<objective>
Create atomic sale creation RPC with stock decrement and movement logging

Purpose: Implement VTA-11 (auto decrement), VTA-12 (block if stock=0) with race condition protection
Output: Migration 023_create_medias_sale_rpc.sql with create_medias_sale function
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-sales-core/11-RESEARCH.md
@supabase/migrations/020_medias_foundation.sql
@supabase/migrations/021_medias_sales.sql (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create atomic sale RPC migration</name>
  <files>supabase/migrations/023_create_medias_sale_rpc.sql</files>
  <action>
Create migration with create_medias_sale RPC following RESEARCH.md pattern:

```sql
CREATE OR REPLACE FUNCTION public.create_medias_sale(
  p_items JSONB,              -- [{product_id, quantity}, ...]
  p_methods JSONB,            -- [{metodo, monto, comprobante_path}, ...]
  p_patient_id UUID,          -- nullable
  p_vendedor_id UUID,         -- required (auth.uid())
  p_receptor_efectivo_id UUID -- nullable (VTA-08)
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_sale_id UUID;
  v_numero_venta TEXT;
  v_subtotal DECIMAL(12,2) := 0;
  v_total DECIMAL(12,2) := 0;
  v_item RECORD;
  v_method RECORD;
  v_product RECORD;
BEGIN
  -- 1. Generate gapless sale number
  v_numero_venta := get_next_venta_number();

  -- 2. First pass: validate all items have sufficient stock
  FOR v_item IN SELECT * FROM jsonb_to_recordset(p_items) AS x(product_id UUID, quantity INTEGER)
  LOOP
    SELECT * INTO v_product
    FROM medias_products
    WHERE id = v_item.product_id
    FOR UPDATE;  -- Lock row

    IF NOT FOUND THEN
      RAISE EXCEPTION 'Producto no encontrado: %', v_item.product_id;
    END IF;

    IF NOT v_product.activo THEN
      RAISE EXCEPTION 'Producto no disponible: %', v_product.codigo;
    END IF;

    -- VTA-12: Block if insufficient stock
    IF v_product.stock_normal < v_item.quantity THEN
      RAISE EXCEPTION 'Stock insuficiente para % (disponible: %, solicitado: %)',
        v_product.codigo, v_product.stock_normal, v_item.quantity;
    END IF;

    -- Accumulate subtotal
    v_subtotal := v_subtotal + (v_product.precio * v_item.quantity);
  END LOOP;

  v_total := v_subtotal;  -- No discounts in medias sales

  -- 3. Create sale header
  INSERT INTO medias_sales (
    numero_venta, patient_id, subtotal, total,
    vendedor_id, receptor_efectivo_id
  ) VALUES (
    v_numero_venta, p_patient_id, v_subtotal, v_total,
    p_vendedor_id, p_receptor_efectivo_id
  ) RETURNING id INTO v_sale_id;

  -- 4. Create items and decrement stock
  FOR v_item IN SELECT * FROM jsonb_to_recordset(p_items) AS x(product_id UUID, quantity INTEGER)
  LOOP
    SELECT * INTO v_product
    FROM medias_products
    WHERE id = v_item.product_id
    FOR UPDATE;

    -- Create sale item with snapshots
    INSERT INTO medias_sale_items (
      sale_id, product_id,
      product_codigo, product_tipo, product_talla,
      unit_price, quantity, subtotal
    ) VALUES (
      v_sale_id, v_item.product_id,
      v_product.codigo, v_product.tipo::text, v_product.talla::text,
      v_product.precio, v_item.quantity, v_product.precio * v_item.quantity
    );

    -- VTA-11: Decrement stock
    UPDATE medias_products
    SET stock_normal = stock_normal - v_item.quantity
    WHERE id = v_item.product_id;

    -- Log stock movement (INV-06, INV-07)
    INSERT INTO medias_stock_movements (
      product_id, tipo, cantidad,
      stock_normal_antes, stock_normal_despues,
      stock_devoluciones_antes, stock_devoluciones_despues,
      referencia_id, referencia_tipo, created_by
    ) VALUES (
      v_item.product_id, 'venta', v_item.quantity,
      v_product.stock_normal, v_product.stock_normal - v_item.quantity,
      v_product.stock_devoluciones, v_product.stock_devoluciones,
      v_sale_id, 'venta', p_vendedor_id
    );
  END LOOP;

  -- 5. Create payment methods
  FOR v_method IN SELECT * FROM jsonb_to_recordset(p_methods) AS x(
    metodo TEXT, monto DECIMAL, comprobante_path TEXT
  )
  LOOP
    INSERT INTO medias_sale_methods (sale_id, metodo, monto, comprobante_path)
    VALUES (v_sale_id, v_method.metodo::payment_method_type, v_method.monto, v_method.comprobante_path);
  END LOOP;

  -- 6. Return result
  RETURN jsonb_build_object(
    'id', v_sale_id,
    'numero_venta', v_numero_venta,
    'total', v_total
  );
END;
$$;
```

Add:
- GRANT EXECUTE ON FUNCTION create_medias_sale TO authenticated
- Comment explaining the function
- Verification DO block checking function exists
  </action>
  <verify>
Run: `grep "FOR UPDATE" supabase/migrations/023_create_medias_sale_rpc.sql` confirms row locking
Run: `grep "Stock insuficiente" supabase/migrations/023_create_medias_sale_rpc.sql` confirms validation
  </verify>
  <done>
RPC function creates sales atomically with stock validation and decrement
  </done>
</task>

</tasks>

<verification>
- [ ] Function accepts items, methods, patient_id, vendedor_id, receptor_efectivo_id
- [ ] FOR UPDATE locks product rows before stock check
- [ ] Raises exception with product code if stock insufficient
- [ ] Creates sale header, items (with snapshots), and methods
- [ ] Decrements stock_normal for each item
- [ ] Logs stock movement with before/after snapshots
- [ ] Returns sale id and numero_venta
</verification>

<success_criteria>
create_medias_sale RPC implements atomic sale creation with race-condition-proof stock management
</success_criteria>

<output>
After completion, create `.planning/phases/11-sales-core/11-03-SUMMARY.md`
</output>
