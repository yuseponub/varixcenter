-- Migration: 015_cash_closings.sql
-- Purpose: Cash closing (Cierre de Caja) system - daily cash reconciliation
-- Phase: 05-cash-closing
-- Created: 2026-01-24
-- NOTE: Sistema de cierre de caja diario con bloqueo de pagos post-cierre

-- ============================================
-- 1. ENUM TYPE FOR CLOSING STATUS
-- ============================================

CREATE TYPE public.cierre_estado AS ENUM ('abierto', 'cerrado', 'reabierto');

COMMENT ON TYPE public.cierre_estado IS 'Estado del cierre de caja: abierto (en proceso), cerrado (finalizado), reabierto (por admin)';

-- ============================================
-- 2. CLOSING COUNTER TABLE (GAPLESS NUMBERING)
-- ============================================

-- Single-row table for gapless sequential closing numbers
-- PostgreSQL sequences have gaps on rollback; this counter ensures gapless numbering
CREATE TABLE public.closing_counter (
  id INTEGER PRIMARY KEY DEFAULT 1,
  last_number BIGINT NOT NULL DEFAULT 0,
  prefix VARCHAR(10) NOT NULL DEFAULT 'CIE',

  -- Single-row enforcement: only id=1 allowed
  CONSTRAINT closing_single_row_enforcement CHECK (id = 1)
);

COMMENT ON TABLE public.closing_counter IS 'Contador de cierres con numeracion secuencial sin gaps - solo una fila permitida';
COMMENT ON COLUMN public.closing_counter.last_number IS 'Ultimo numero de cierre generado';
COMMENT ON COLUMN public.closing_counter.prefix IS 'Prefijo para el numero de cierre (ej: CIE)';

-- Initialize counter with single row
INSERT INTO public.closing_counter (id, last_number, prefix) VALUES (1, 0, 'CIE');

-- ============================================
-- 3. CLOSING COUNTER PROTECTION TRIGGER
-- ============================================

-- Prevent DELETE and multiple INSERTs on closing_counter
CREATE OR REPLACE FUNCTION public.protect_closing_counter()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'No se puede eliminar el contador de cierres';
  END IF;

  IF TG_OP = 'INSERT' THEN
    IF (SELECT COUNT(*) FROM public.closing_counter) > 0 THEN
      RAISE EXCEPTION 'Solo puede existir un contador de cierres';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER tr_protect_closing_counter
  BEFORE INSERT OR DELETE ON public.closing_counter
  FOR EACH ROW
  EXECUTE FUNCTION public.protect_closing_counter();

-- ============================================
-- 4. GET NEXT CLOSING NUMBER FUNCTION
-- ============================================

-- Atomically get next closing number with exclusive row lock
-- CRITICAL: Called within transaction, uses FOR UPDATE to prevent race conditions
CREATE OR REPLACE FUNCTION public.get_next_closing_number()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  next_num BIGINT;
  prefix_val VARCHAR(10);
BEGIN
  -- Lock the counter row exclusively (FOR UPDATE)
  -- This prevents concurrent transactions from getting the same number
  SELECT last_number + 1, prefix
  INTO next_num, prefix_val
  FROM public.closing_counter
  WHERE id = 1
  FOR UPDATE;

  -- Update the counter atomically
  UPDATE public.closing_counter
  SET last_number = next_num
  WHERE id = 1;

  -- Return formatted closing number: CIE-000001
  RETURN prefix_val || '-' || LPAD(next_num::text, 6, '0');
END;
$$;

COMMENT ON FUNCTION public.get_next_closing_number() IS 'Genera el siguiente numero de cierre con bloqueo exclusivo para evitar gaps';

-- ============================================
-- 5. CASH_CLOSINGS TABLE
-- ============================================

CREATE TABLE public.cash_closings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Sequential closing number (generated by get_next_closing_number())
  cierre_numero VARCHAR(20) NOT NULL UNIQUE,

  -- Date this closing covers (one closing per day)
  fecha_cierre DATE NOT NULL UNIQUE,

  -- Calculated totals from payments (snapshot at closing time)
  total_efectivo DECIMAL(12,2) NOT NULL DEFAULT 0,
  total_tarjeta DECIMAL(12,2) NOT NULL DEFAULT 0,
  total_transferencia DECIMAL(12,2) NOT NULL DEFAULT 0,
  total_nequi DECIMAL(12,2) NOT NULL DEFAULT 0,
  total_descuentos DECIMAL(12,2) NOT NULL DEFAULT 0,
  total_anulaciones DECIMAL(12,2) NOT NULL DEFAULT 0,
  grand_total DECIMAL(12,2) NOT NULL DEFAULT 0,

  -- Physical cash count entered by secretary
  conteo_fisico_efectivo DECIMAL(12,2) NOT NULL,

  -- Difference (conteo - total_efectivo), calculated
  diferencia DECIMAL(12,2) NOT NULL DEFAULT 0,

  -- MANDATORY if diferencia != 0 (zero tolerance policy)
  diferencia_justificacion TEXT,

  -- Photo of signed printed report (mandatory)
  cierre_photo_path TEXT NOT NULL,

  -- Status
  estado public.cierre_estado NOT NULL DEFAULT 'cerrado',

  -- Optional notes
  notas TEXT,

  -- Who closed
  closed_by UUID NOT NULL REFERENCES auth.users(id),

  -- Reopen tracking (only admin can reopen)
  reopened_by UUID REFERENCES auth.users(id),
  reopened_at TIMESTAMPTZ,
  reopen_justificacion TEXT,

  -- Audit timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- ============================================
  -- CONSTRAINTS
  -- ============================================

  -- All totals must be non-negative
  CONSTRAINT total_efectivo_positive CHECK (total_efectivo >= 0),
  CONSTRAINT total_tarjeta_positive CHECK (total_tarjeta >= 0),
  CONSTRAINT total_transferencia_positive CHECK (total_transferencia >= 0),
  CONSTRAINT total_nequi_positive CHECK (total_nequi >= 0),
  CONSTRAINT total_descuentos_positive CHECK (total_descuentos >= 0),
  CONSTRAINT total_anulaciones_positive CHECK (total_anulaciones >= 0),
  CONSTRAINT grand_total_positive CHECK (grand_total >= 0),
  CONSTRAINT conteo_fisico_positive CHECK (conteo_fisico_efectivo >= 0),

  -- ZERO TOLERANCE: If there's a difference, justification is required
  CONSTRAINT diferencia_requires_justificacion CHECK (
    diferencia = 0 OR (diferencia_justificacion IS NOT NULL AND LENGTH(TRIM(diferencia_justificacion)) >= 10)
  ),

  -- Reopen must have justification
  CONSTRAINT reopen_requires_justificacion CHECK (
    reopened_by IS NULL OR (reopen_justificacion IS NOT NULL AND LENGTH(TRIM(reopen_justificacion)) >= 10)
  )
);

-- Table comments
COMMENT ON TABLE public.cash_closings IS 'Cierres de caja diarios - un cierre por dia, bloquea pagos post-cierre';
COMMENT ON COLUMN public.cash_closings.cierre_numero IS 'Numero de cierre secuencial sin gaps (CIE-000001)';
COMMENT ON COLUMN public.cash_closings.fecha_cierre IS 'Fecha que cubre este cierre (UNIQUE - un cierre por dia)';
COMMENT ON COLUMN public.cash_closings.conteo_fisico_efectivo IS 'Conteo fisico del efectivo ingresado por secretaria';
COMMENT ON COLUMN public.cash_closings.diferencia IS 'Diferencia entre conteo fisico y total efectivo calculado';
COMMENT ON COLUMN public.cash_closings.diferencia_justificacion IS 'Obligatorio si diferencia != 0 (tolerancia cero)';
COMMENT ON COLUMN public.cash_closings.cierre_photo_path IS 'Ruta en Storage de la foto del reporte impreso firmado';
COMMENT ON COLUMN public.cash_closings.estado IS 'cerrado = normal, reabierto = admin lo reabrio con justificacion';

-- ============================================
-- 6. INDEXES
-- ============================================

CREATE INDEX idx_cash_closings_fecha ON public.cash_closings(fecha_cierre DESC);
CREATE INDEX idx_cash_closings_estado ON public.cash_closings(estado);
CREATE INDEX idx_cash_closings_created_at ON public.cash_closings(created_at DESC);

-- ============================================
-- 7. IMMUTABILITY TRIGGER FOR CASH_CLOSINGS
-- ============================================

-- Only allows estado transitions:
-- 'cerrado' -> 'reabierto' (with justification)
-- 'reabierto' -> 'cerrado' (re-closing)
CREATE OR REPLACE FUNCTION public.enforce_cash_closing_immutability()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  -- Cannot delete cash closings
  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'No se pueden eliminar cierres de caja';
  END IF;

  -- UPDATE restrictions
  IF TG_OP = 'UPDATE' THEN
    -- Core fields are immutable
    IF OLD.cierre_numero IS DISTINCT FROM NEW.cierre_numero THEN
      RAISE EXCEPTION 'No se puede modificar el numero de cierre';
    END IF;

    IF OLD.fecha_cierre IS DISTINCT FROM NEW.fecha_cierre THEN
      RAISE EXCEPTION 'No se puede modificar la fecha de cierre';
    END IF;

    IF OLD.closed_by IS DISTINCT FROM NEW.closed_by THEN
      RAISE EXCEPTION 'No se puede modificar quien cerro';
    END IF;

    IF OLD.created_at IS DISTINCT FROM NEW.created_at THEN
      RAISE EXCEPTION 'No se puede modificar la fecha de creacion';
    END IF;

    -- Totals are immutable
    IF OLD.total_efectivo IS DISTINCT FROM NEW.total_efectivo
       OR OLD.total_tarjeta IS DISTINCT FROM NEW.total_tarjeta
       OR OLD.total_transferencia IS DISTINCT FROM NEW.total_transferencia
       OR OLD.total_nequi IS DISTINCT FROM NEW.total_nequi
       OR OLD.total_descuentos IS DISTINCT FROM NEW.total_descuentos
       OR OLD.total_anulaciones IS DISTINCT FROM NEW.total_anulaciones
       OR OLD.grand_total IS DISTINCT FROM NEW.grand_total THEN
      RAISE EXCEPTION 'No se pueden modificar los totales del cierre';
    END IF;

    IF OLD.conteo_fisico_efectivo IS DISTINCT FROM NEW.conteo_fisico_efectivo THEN
      RAISE EXCEPTION 'No se puede modificar el conteo fisico';
    END IF;

    IF OLD.diferencia IS DISTINCT FROM NEW.diferencia THEN
      RAISE EXCEPTION 'No se puede modificar la diferencia';
    END IF;

    IF OLD.diferencia_justificacion IS DISTINCT FROM NEW.diferencia_justificacion THEN
      RAISE EXCEPTION 'No se puede modificar la justificacion de diferencia';
    END IF;

    IF OLD.cierre_photo_path IS DISTINCT FROM NEW.cierre_photo_path THEN
      RAISE EXCEPTION 'No se puede modificar la foto del cierre';
    END IF;

    -- Estado transitions
    IF OLD.estado IS DISTINCT FROM NEW.estado THEN
      -- Only allowed transitions
      IF OLD.estado = 'cerrado' AND NEW.estado = 'reabierto' THEN
        -- Valid: reopen requires justification (checked by constraint)
        IF NEW.reopened_by IS NULL THEN
          RAISE EXCEPTION 'Se requiere registrar quien reabre el cierre';
        END IF;
        NEW.reopened_at := now();
      ELSIF OLD.estado = 'reabierto' AND NEW.estado = 'cerrado' THEN
        -- Valid: re-closing (just update estado)
        NULL;
      ELSE
        RAISE EXCEPTION 'Transicion de estado no permitida: % -> %', OLD.estado, NEW.estado;
      END IF;
    END IF;

    NEW.updated_at := now();
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER tr_cash_closing_immutability
  BEFORE UPDATE OR DELETE ON public.cash_closings
  FOR EACH ROW
  EXECUTE FUNCTION public.enforce_cash_closing_immutability();

-- ============================================
-- 8. BLOCK PAYMENTS ON CLOSED DAYS TRIGGER
-- ============================================

-- CRITICAL: Prevents creating payments on days that have been closed
CREATE OR REPLACE FUNCTION public.block_payments_on_closed_day()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_payment_date DATE;
  v_closing_exists BOOLEAN;
BEGIN
  -- Get the date of the payment (using created_at)
  v_payment_date := DATE(NEW.created_at);

  -- Check if there's a closed cierre for this date
  SELECT EXISTS (
    SELECT 1 FROM public.cash_closings
    WHERE fecha_cierre = v_payment_date
    AND estado = 'cerrado'
  ) INTO v_closing_exists;

  IF v_closing_exists THEN
    RAISE EXCEPTION 'No se pueden crear pagos en un dia cerrado (%). El cierre debe reabrirse primero.', v_payment_date;
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER tr_block_payments_on_closed_day
  BEFORE INSERT ON public.payments
  FOR EACH ROW
  EXECUTE FUNCTION public.block_payments_on_closed_day();

COMMENT ON FUNCTION public.block_payments_on_closed_day() IS 'Bloquea la creacion de pagos en dias que ya fueron cerrados';

-- ============================================
-- 9. ROW LEVEL SECURITY
-- ============================================

ALTER TABLE public.cash_closings ENABLE ROW LEVEL SECURITY;

-- All staff can view closings
CREATE POLICY "Staff can view cash closings"
  ON public.cash_closings FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico', 'enfermera', 'secretaria')
    )
  );

-- Only secretaria and admin can create closings
CREATE POLICY "Secretaria and admin can create closings"
  ON public.cash_closings FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'secretaria')
    )
  );

-- Only admin can update (reopen) closings
CREATE POLICY "Admin can update closings"
  ON public.cash_closings FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  );

-- NO DELETE policy (closings cannot be deleted)

-- CLOSING_COUNTER TABLE RLS (admin only)
ALTER TABLE public.closing_counter ENABLE ROW LEVEL SECURITY;

-- Only admin can view counter
CREATE POLICY "Admin can view closing counter"
  ON public.closing_counter FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  );

-- Allow UPDATE for closing number generation (via function)
CREATE POLICY "Allow closing counter update"
  ON public.closing_counter FOR UPDATE
  TO authenticated
  WITH CHECK (true);

-- ============================================
-- 10. GRANT PERMISSIONS
-- ============================================

GRANT SELECT, INSERT ON public.cash_closings TO authenticated;
GRANT UPDATE (estado, reopened_by, reopen_justificacion, reopened_at, notas, updated_at) ON public.cash_closings TO authenticated;
GRANT SELECT, UPDATE ON public.closing_counter TO authenticated;

-- ============================================
-- 11. VERIFICATION
-- ============================================

DO $$
BEGIN
  -- Check cash_closings table exists
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'cash_closings'
  ) THEN
    RAISE EXCEPTION 'cash_closings table not created';
  END IF;

  -- Check RLS is enabled
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'cash_closings' AND rowsecurity = true
  ) THEN
    RAISE EXCEPTION 'RLS not enabled on cash_closings table';
  END IF;

  -- Check closing_counter exists
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'closing_counter'
  ) THEN
    RAISE EXCEPTION 'closing_counter table not created';
  END IF;

  -- Check closing_counter has exactly one row
  IF (SELECT COUNT(*) FROM public.closing_counter) != 1 THEN
    RAISE EXCEPTION 'closing_counter must have exactly one row';
  END IF;

  RAISE NOTICE 'Cash closings migration verified successfully';
END;
$$;
