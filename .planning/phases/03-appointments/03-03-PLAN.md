---
phase: 03-appointments
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/queries/appointments.ts
autonomous: true

must_haves:
  truths:
    - "Appointments can be fetched for calendar view with date range filter"
    - "Appointments can be filtered by doctor (APT-02)"
    - "Query returns data in FullCalendar event format"
  artifacts:
    - path: "src/lib/queries/appointments.ts"
      provides: "Supabase query functions"
      exports: ["getAppointmentsForCalendar", "getAppointmentById", "getDoctors"]
  key_links:
    - from: "src/lib/queries/appointments.ts"
      to: "supabase client"
      via: "import"
      pattern: "createClient.*supabase/server"
    - from: "src/lib/queries/appointments.ts"
      to: "appointments table"
      via: "supabase query"
      pattern: "from\\('appointments'\\)"
---

<objective>
Create Supabase query functions for appointments including calendar view, single appointment fetch, and doctor list.

Purpose: Provide the data access layer that server components and actions will use to fetch appointment data.
Output: Query functions that return typed data with patient and doctor relations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-appointments/03-RESEARCH.md
@src/lib/queries/patients.ts
@src/types/appointments.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create appointment query functions</name>
  <files>src/lib/queries/appointments.ts</files>
  <action>
Create `src/lib/queries/appointments.ts` following the pattern from patients.ts:

```typescript
import { createClient } from '@/lib/supabase/server'
import {
  CalendarEvent,
  AppointmentWithPatient,
  AppointmentWithRelations,
  Doctor,
  AppointmentStatus
} from '@/types/appointments'
import { STATUS_HEX_COLORS } from '@/lib/appointments/state-machine'

/**
 * Get appointments for calendar view within a date range
 *
 * Used by: Calendar page, main agenda view
 * Returns: FullCalendar-compatible events
 *
 * @param startDate - ISO date string (start of visible range)
 * @param endDate - ISO date string (end of visible range)
 * @param doctorId - Optional filter by doctor (APT-02)
 */
export async function getAppointmentsForCalendar(
  startDate: string,
  endDate: string,
  doctorId?: string | null
): Promise<CalendarEvent[]> {
  const supabase = await createClient()

  let query = supabase
    .from('appointments')
    .select(`
      id,
      fecha_hora_inicio,
      fecha_hora_fin,
      estado,
      notas,
      doctor_id,
      patient:patients!patient_id (
        id,
        nombre,
        apellido
      )
    `)
    .gte('fecha_hora_inicio', startDate)
    .lte('fecha_hora_inicio', endDate)
    .order('fecha_hora_inicio', { ascending: true })

  // APT-02: Filter by doctor if specified
  if (doctorId) {
    query = query.eq('doctor_id', doctorId)
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching appointments:', error)
    throw error
  }

  // Transform to FullCalendar event format
  return (data || []).map((apt) => ({
    id: apt.id,
    title: `${apt.patient.nombre} ${apt.patient.apellido}`,
    start: apt.fecha_hora_inicio,
    end: apt.fecha_hora_fin,
    backgroundColor: STATUS_HEX_COLORS[apt.estado as AppointmentStatus],
    borderColor: STATUS_HEX_COLORS[apt.estado as AppointmentStatus],
    extendedProps: {
      patientId: apt.patient.id,
      patientName: `${apt.patient.nombre} ${apt.patient.apellido}`,
      doctorId: apt.doctor_id,
      doctorName: '', // Will be enriched by getDoctorName if needed
      status: apt.estado as AppointmentStatus,
      notas: apt.notas
    }
  }))
}

/**
 * Get a single appointment by ID with full relations
 *
 * Used by: Appointment detail view, edit dialog
 */
export async function getAppointmentById(
  appointmentId: string
): Promise<AppointmentWithRelations | null> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('appointments')
    .select(`
      *,
      patient:patients!patient_id (
        id,
        nombre,
        apellido,
        cedula,
        celular
      )
    `)
    .eq('id', appointmentId)
    .single()

  if (error) {
    if (error.code === 'PGRST116') {
      return null // Not found
    }
    console.error('Error fetching appointment:', error)
    throw error
  }

  // Fetch doctor email from auth.users
  const { data: userData } = await supabase.auth.admin.getUserById(data.doctor_id)

  return {
    ...data,
    patient: data.patient,
    doctor: {
      id: data.doctor_id,
      email: userData?.user?.email || 'Desconocido'
    }
  } as AppointmentWithRelations
}

/**
 * Get list of doctors for filter dropdown (APT-02)
 *
 * Doctors are users with role='medico' in user_roles table
 * Returns display-friendly format with name from raw_user_meta_data
 */
export async function getDoctors(): Promise<Doctor[]> {
  const supabase = await createClient()

  // Get users with medico role
  const { data: doctorRoles, error: rolesError } = await supabase
    .from('user_roles')
    .select('user_id')
    .eq('role', 'medico')

  if (rolesError) {
    console.error('Error fetching doctor roles:', error)
    throw rolesError
  }

  if (!doctorRoles || doctorRoles.length === 0) {
    return []
  }

  // For each doctor, get user info
  // Note: In production, this should use a view or function for efficiency
  const doctors: Doctor[] = []

  for (const role of doctorRoles) {
    const { data: userData } = await supabase.auth.admin.getUserById(role.user_id)

    if (userData?.user) {
      const user = userData.user
      // Try to get name from user_metadata, fallback to email
      const nombre = user.user_metadata?.nombre ||
                     user.user_metadata?.full_name ||
                     user.email?.split('@')[0] ||
                     'Doctor'

      doctors.push({
        id: user.id,
        nombre: nombre
      })
    }
  }

  return doctors
}

/**
 * Get appointments for a specific patient (for timeline)
 *
 * Used by: Patient detail page timeline
 */
export async function getAppointmentsByPatient(
  patientId: string
): Promise<AppointmentWithPatient[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('appointments')
    .select(`
      *,
      patient:patients!patient_id (
        id,
        nombre,
        apellido,
        cedula,
        celular
      )
    `)
    .eq('patient_id', patientId)
    .order('fecha_hora_inicio', { ascending: false })

  if (error) {
    console.error('Error fetching patient appointments:', error)
    throw error
  }

  return data as AppointmentWithPatient[]
}

/**
 * Count appointments for a date (for quick stats)
 */
export async function countAppointmentsForDate(
  date: string,
  doctorId?: string
): Promise<number> {
  const supabase = await createClient()

  // Start and end of the given date
  const startOfDay = `${date}T00:00:00`
  const endOfDay = `${date}T23:59:59`

  let query = supabase
    .from('appointments')
    .select('id', { count: 'exact', head: true })
    .gte('fecha_hora_inicio', startOfDay)
    .lte('fecha_hora_inicio', endOfDay)
    .not('estado', 'in', '(cancelada,no_asistio)')

  if (doctorId) {
    query = query.eq('doctor_id', doctorId)
  }

  const { count, error } = await query

  if (error) {
    console.error('Error counting appointments:', error)
    return 0
  }

  return count || 0
}
```
  </action>
  <verify>
- File exists at `src/lib/queries/appointments.ts`
- `npm run build` passes
- Functions getAppointmentsForCalendar, getAppointmentById, getDoctors are exported
  </verify>
  <done>
- getAppointmentsForCalendar returns FullCalendar-formatted events with date range and doctor filter
- getAppointmentById returns full appointment with patient and doctor relations
- getDoctors returns list for APT-02 filter dropdown
- getAppointmentsByPatient ready for patient timeline integration
- countAppointmentsForDate ready for quick stats display
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. All query functions are exported
3. getAppointmentsForCalendar accepts doctorId parameter (APT-02)
4. CalendarEvent format matches FullCalendar requirements
</verification>

<success_criteria>
- Date range filtering works for calendar view
- Doctor filtering works for APT-02 requirement
- Patient relation joined for display names
- TypeScript types match return values
- Error handling follows existing patterns
</success_criteria>

<output>
After completion, create `.planning/phases/03-appointments/03-03-SUMMARY.md`
</output>
