-- Migration: 031_purchases_tables.sql
-- Purpose: Purchases schema for supplier invoice registration with two-step reception flow
-- Phase: 13-purchases, Plan: 01
-- Created: 2026-01-26
-- Depends on: 020_medias_foundation.sql (medias_products), 001_rbac_foundation.sql (user_roles)
--
-- Requirements covered by this migration:
--   COM-01: Purchases table with header information
--   COM-02: Purchase items with product snapshots and costo_unitario for margin analysis
--   COM-03: Gapless sequential numbering (COM-000001)
--   COM-04: Factura photo/PDF path REQUIRED for every purchase
--   COM-05: Two-step flow: pendiente_recepcion -> recibido
--   COM-06: Anulacion with justification for audit trail

-- ============================================================================
-- 1. ENUM TYPES
-- ============================================================================

-- Purchase status (two-step reception flow + anulado)
CREATE TYPE public.compra_estado AS ENUM (
  'pendiente_recepcion',  -- Registered but stock not yet received
  'recibido',             -- Stock confirmed received (triggers stock increment)
  'anulado'               -- Cancelled (reverts stock if already received)
);

COMMENT ON TYPE public.compra_estado IS 'Estado de compra: pendiente_recepcion, recibido (incrementa stock), anulado';

-- ============================================================================
-- 2. PURCHASE COUNTER TABLE (GAPLESS NUMBERING)
-- ============================================================================
-- COM-03: Numeros de compra son secuenciales automaticos y nunca se reutilizan
-- Single-row table for gapless sequential purchase numbers

CREATE TABLE public.purchase_counter (
  id INTEGER PRIMARY KEY DEFAULT 1,
  last_number BIGINT NOT NULL DEFAULT 0,
  prefix VARCHAR(10) NOT NULL DEFAULT 'COM',

  -- Single-row enforcement: only id=1 allowed
  CONSTRAINT purchase_counter_single_row CHECK (id = 1)
);

COMMENT ON TABLE public.purchase_counter IS 'Contador de compras con numeracion secuencial sin gaps - solo una fila permitida (COM-03)';
COMMENT ON COLUMN public.purchase_counter.last_number IS 'Ultimo numero de compra generado';
COMMENT ON COLUMN public.purchase_counter.prefix IS 'Prefijo para el numero de compra (COM)';

-- Initialize counter with single row
INSERT INTO public.purchase_counter (id, last_number, prefix) VALUES (1, 0, 'COM');

-- ============================================================================
-- 3. PURCHASE COUNTER PROTECTION TRIGGER
-- ============================================================================

-- Prevent DELETE and multiple INSERTs on purchase_counter
CREATE OR REPLACE FUNCTION public.protect_purchase_counter()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'No se puede eliminar el contador de compras';
  END IF;

  IF TG_OP = 'INSERT' THEN
    IF (SELECT COUNT(*) FROM public.purchase_counter) > 0 THEN
      RAISE EXCEPTION 'Solo puede existir un contador de compras';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER tr_protect_purchase_counter
  BEFORE INSERT OR DELETE ON public.purchase_counter
  FOR EACH ROW
  EXECUTE FUNCTION public.protect_purchase_counter();

-- ============================================================================
-- 4. GET NEXT COMPRA NUMBER FUNCTION
-- ============================================================================

-- Atomically get next purchase number with exclusive row lock
-- CRITICAL: Called within transaction, uses FOR UPDATE to prevent race conditions
-- COM-03: Ensures gapless sequential numbering
CREATE OR REPLACE FUNCTION public.get_next_compra_number()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  next_num BIGINT;
  prefix_val VARCHAR(10);
BEGIN
  -- Lock the counter row exclusively (FOR UPDATE)
  -- This prevents concurrent transactions from getting the same number
  SELECT last_number + 1, prefix
  INTO next_num, prefix_val
  FROM public.purchase_counter
  WHERE id = 1
  FOR UPDATE;

  -- Update the counter atomically
  UPDATE public.purchase_counter
  SET last_number = next_num
  WHERE id = 1;

  -- Return formatted compra number: COM-000001
  RETURN prefix_val || '-' || LPAD(next_num::text, 6, '0');
END;
$$;

COMMENT ON FUNCTION public.get_next_compra_number() IS 'Genera el siguiente numero de compra con bloqueo exclusivo para evitar gaps (COM-03)';

-- ============================================================================
-- 5. PURCHASES TABLE (HEADER)
-- ============================================================================

CREATE TABLE public.purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Purchase number (generated by get_next_compra_number())
  -- COM-03: Sequential, never reused
  numero_compra VARCHAR(20) NOT NULL UNIQUE,

  -- Supplier (free text per CONTEXT.md - no catalog)
  proveedor VARCHAR(200) NOT NULL,

  -- Invoice details
  fecha_factura DATE NOT NULL,
  numero_factura VARCHAR(100),  -- Optional per CONTEXT.md

  -- Total amount
  total DECIMAL(12,2) NOT NULL,

  -- Invoice photo/PDF path (Supabase Storage)
  -- COM-04: REQUIRED for every purchase
  factura_path VARCHAR(500) NOT NULL,

  -- Status (two-step reception flow)
  -- COM-05: pendiente_recepcion -> recibido triggers stock increment
  estado public.compra_estado NOT NULL DEFAULT 'pendiente_recepcion',

  -- Optional notes
  notas TEXT,

  -- Who created the purchase
  created_by UUID NOT NULL REFERENCES auth.users(id),

  -- Reception confirmation fields (populated when estado -> recibido)
  recibido_por UUID REFERENCES auth.users(id),
  recibido_at TIMESTAMPTZ,

  -- Anulacion fields (populated when estado -> anulado)
  -- COM-06: Justification required for audit trail
  anulado_por UUID REFERENCES auth.users(id),
  anulado_at TIMESTAMPTZ,
  anulacion_justificacion TEXT,

  -- Audit timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- ============================================================================
  -- CONSTRAINTS
  -- ============================================================================

  -- Total must be positive
  CONSTRAINT purchases_total_positive CHECK (total > 0),

  -- Anulacion requires justification
  CONSTRAINT purchases_anulacion_justificacion_required CHECK (
    estado != 'anulado' OR anulacion_justificacion IS NOT NULL
  ),

  -- Reception fields must be set together
  CONSTRAINT purchases_recepcion_fields_consistent CHECK (
    (recibido_por IS NULL AND recibido_at IS NULL) OR
    (recibido_por IS NOT NULL AND recibido_at IS NOT NULL)
  ),

  -- Anulacion fields must be set together
  CONSTRAINT purchases_anulacion_fields_consistent CHECK (
    (anulado_por IS NULL AND anulado_at IS NULL) OR
    (anulado_por IS NOT NULL AND anulado_at IS NOT NULL)
  )
);

-- Table comments
COMMENT ON TABLE public.purchases IS 'Compras de mercancia con flujo de dos pasos: registro -> confirmacion de recepcion';
COMMENT ON COLUMN public.purchases.numero_compra IS 'Numero de compra secuencial sin gaps COM-000001 (COM-03)';
COMMENT ON COLUMN public.purchases.proveedor IS 'Nombre del proveedor (texto libre - no catalogo)';
COMMENT ON COLUMN public.purchases.fecha_factura IS 'Fecha de la factura del proveedor';
COMMENT ON COLUMN public.purchases.numero_factura IS 'Numero de factura del proveedor (opcional)';
COMMENT ON COLUMN public.purchases.total IS 'Total de la factura en pesos colombianos';
COMMENT ON COLUMN public.purchases.factura_path IS 'Ruta en Supabase Storage - OBLIGATORIO foto/PDF de factura (COM-04)';
COMMENT ON COLUMN public.purchases.estado IS 'Estado: pendiente_recepcion -> recibido (incrementa stock) o anulado';
COMMENT ON COLUMN public.purchases.notas IS 'Notas adicionales opcionales';
COMMENT ON COLUMN public.purchases.created_by IS 'Usuario que registro la compra';
COMMENT ON COLUMN public.purchases.recibido_por IS 'Usuario que confirmo recepcion de mercancia';
COMMENT ON COLUMN public.purchases.recibido_at IS 'Fecha/hora de confirmacion de recepcion';
COMMENT ON COLUMN public.purchases.anulado_por IS 'Usuario que anulo la compra';
COMMENT ON COLUMN public.purchases.anulado_at IS 'Fecha/hora de anulacion';
COMMENT ON COLUMN public.purchases.anulacion_justificacion IS 'Justificacion obligatoria al anular (COM-06)';

-- ============================================================================
-- 6. PURCHASE_ITEMS TABLE (LINE ITEMS WITH SNAPSHOTS)
-- ============================================================================

CREATE TABLE public.purchase_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Purchase reference (RESTRICT delete to protect data integrity)
  purchase_id UUID NOT NULL REFERENCES public.purchases(id) ON DELETE RESTRICT,

  -- Product reference (keeps link for analytics)
  product_id UUID NOT NULL REFERENCES public.medias_products(id) ON DELETE RESTRICT,

  -- Snapshot of product at time of purchase (IMMUTABLE - even if product changes later)
  product_codigo VARCHAR(20) NOT NULL,
  product_tipo VARCHAR(20) NOT NULL,
  product_talla VARCHAR(10) NOT NULL,

  -- Quantity purchased
  cantidad INTEGER NOT NULL,

  -- Cost per unit (for margin analysis in reports per CONTEXT.md)
  costo_unitario DECIMAL(12,2) NOT NULL,

  -- Calculated subtotal
  subtotal DECIMAL(12,2) NOT NULL,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- ============================================================================
  -- CONSTRAINTS
  -- ============================================================================

  -- Quantity must be positive
  CONSTRAINT purchase_items_cantidad_positive CHECK (cantidad > 0),

  -- Cost must be non-negative
  CONSTRAINT purchase_items_costo_positive CHECK (costo_unitario >= 0),

  -- Subtotal must be non-negative
  CONSTRAINT purchase_items_subtotal_positive CHECK (subtotal >= 0)
);

-- Table comments
COMMENT ON TABLE public.purchase_items IS 'Items de compra con snapshot del producto y costo unitario para analisis de margenes';
COMMENT ON COLUMN public.purchase_items.purchase_id IS 'Referencia a la compra padre';
COMMENT ON COLUMN public.purchase_items.product_id IS 'Referencia al producto (para analytics)';
COMMENT ON COLUMN public.purchase_items.product_codigo IS 'Codigo del producto al momento de la compra (snapshot inmutable)';
COMMENT ON COLUMN public.purchase_items.product_tipo IS 'Tipo del producto al momento de la compra (snapshot inmutable)';
COMMENT ON COLUMN public.purchase_items.product_talla IS 'Talla del producto al momento de la compra (snapshot inmutable)';
COMMENT ON COLUMN public.purchase_items.cantidad IS 'Cantidad comprada';
COMMENT ON COLUMN public.purchase_items.costo_unitario IS 'Costo por unidad para analisis de margenes';
COMMENT ON COLUMN public.purchase_items.subtotal IS 'Subtotal calculado (cantidad * costo_unitario)';

-- ============================================================================
-- 7. INDEXES
-- ============================================================================

-- Purchases indexes
CREATE INDEX idx_purchases_estado ON public.purchases(estado);
CREATE INDEX idx_purchases_fecha_factura ON public.purchases(fecha_factura);
CREATE INDEX idx_purchases_proveedor ON public.purchases(proveedor);
CREATE INDEX idx_purchases_created_at ON public.purchases(created_at DESC);

-- Purchase items indexes
CREATE INDEX idx_purchase_items_purchase ON public.purchase_items(purchase_id);

-- ============================================================================
-- 8. UPDATED_AT TRIGGER FOR PURCHASES
-- ============================================================================

CREATE TRIGGER tr_purchases_updated_at
  BEFORE UPDATE ON public.purchases
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at();

-- ============================================================================
-- 9. ROW LEVEL SECURITY - PURCHASES
-- ============================================================================

ALTER TABLE public.purchases ENABLE ROW LEVEL SECURITY;

-- All authenticated users can view purchases
CREATE POLICY "Authenticated users can view purchases"
  ON public.purchases FOR SELECT
  TO authenticated
  USING (true);

-- All authenticated users can create purchases (per CONTEXT.md)
CREATE POLICY "Authenticated users can create purchases"
  ON public.purchases FOR INSERT
  TO authenticated
  WITH CHECK (created_by = auth.uid());

-- Only admin and medico can update purchases directly
-- Enfermera restricted (handled in app layer via alerts per CONTEXT.md)
CREATE POLICY "Admin and medico can update purchases"
  ON public.purchases FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico')
    )
  );

-- Only admin and medico can delete purchases
CREATE POLICY "Admin and medico can delete purchases"
  ON public.purchases FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico')
    )
  );

-- ============================================================================
-- 10. ROW LEVEL SECURITY - PURCHASE_ITEMS
-- ============================================================================

ALTER TABLE public.purchase_items ENABLE ROW LEVEL SECURITY;

-- All authenticated users can view purchase items
CREATE POLICY "Authenticated users can view purchase items"
  ON public.purchase_items FOR SELECT
  TO authenticated
  USING (true);

-- All authenticated users can create purchase items
CREATE POLICY "Authenticated users can create purchase items"
  ON public.purchase_items FOR INSERT
  TO authenticated
  WITH CHECK (true);

-- Only admin and medico can update purchase items
CREATE POLICY "Admin and medico can update purchase items"
  ON public.purchase_items FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico')
    )
  );

-- Only admin and medico can delete purchase items
CREATE POLICY "Admin and medico can delete purchase items"
  ON public.purchase_items FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico')
    )
  );

-- ============================================================================
-- 11. ROW LEVEL SECURITY - PURCHASE_COUNTER
-- ============================================================================

ALTER TABLE public.purchase_counter ENABLE ROW LEVEL SECURITY;

-- Only admin can view purchase counter
CREATE POLICY "Admin can view purchase counter"
  ON public.purchase_counter FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  );

-- Allow UPDATE for compra number generation (via function)
CREATE POLICY "Allow purchase counter update"
  ON public.purchase_counter FOR UPDATE
  TO authenticated
  WITH CHECK (true);

-- ============================================================================
-- 12. GRANT PERMISSIONS
-- ============================================================================

-- Purchases: authenticated can SELECT, INSERT; admin/medico UPDATE, DELETE via RLS
GRANT SELECT, INSERT, UPDATE, DELETE ON public.purchases TO authenticated;

-- Purchase items: authenticated can SELECT, INSERT; admin/medico UPDATE, DELETE via RLS
GRANT SELECT, INSERT, UPDATE, DELETE ON public.purchase_items TO authenticated;

-- Purchase counter: authenticated can SELECT, UPDATE
GRANT SELECT, UPDATE ON public.purchase_counter TO authenticated;

-- ============================================================================
-- 13. AUDIT LOGGING
-- ============================================================================

-- Enable audit for purchases tables (uses function from 002_audit_infrastructure.sql)
SELECT enable_audit_for_table('public.purchases');
SELECT enable_audit_for_table('public.purchase_items');

-- ============================================================================
-- 14. VERIFICATION
-- ============================================================================

DO $$
DECLARE
  v_has_compra_estado BOOLEAN;
  v_has_purchase_counter BOOLEAN;
  v_counter_initialized BOOLEAN;
  v_rls_purchases BOOLEAN;
  v_rls_items BOOLEAN;
  v_rls_counter BOOLEAN;
  v_has_updated_at_trigger BOOLEAN;
BEGIN
  -- Verify compra_estado ENUM exists with correct values
  SELECT EXISTS (
    SELECT 1 FROM pg_type
    WHERE typname = 'compra_estado'
  ) INTO v_has_compra_estado;

  IF NOT v_has_compra_estado THEN
    RAISE EXCEPTION 'compra_estado ENUM not created';
  END IF;

  -- Verify ENUM values
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum e
    JOIN pg_type t ON e.enumtypid = t.oid
    WHERE t.typname = 'compra_estado' AND e.enumlabel = 'pendiente_recepcion'
  ) THEN
    RAISE EXCEPTION 'compra_estado missing pendiente_recepcion value';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_enum e
    JOIN pg_type t ON e.enumtypid = t.oid
    WHERE t.typname = 'compra_estado' AND e.enumlabel = 'recibido'
  ) THEN
    RAISE EXCEPTION 'compra_estado missing recibido value';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_enum e
    JOIN pg_type t ON e.enumtypid = t.oid
    WHERE t.typname = 'compra_estado' AND e.enumlabel = 'anulado'
  ) THEN
    RAISE EXCEPTION 'compra_estado missing anulado value';
  END IF;

  -- Verify purchase_counter exists
  SELECT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'purchase_counter'
  ) INTO v_has_purchase_counter;

  IF NOT v_has_purchase_counter THEN
    RAISE EXCEPTION 'purchase_counter table not created';
  END IF;

  -- Verify counter is initialized correctly
  SELECT EXISTS (
    SELECT 1 FROM public.purchase_counter
    WHERE id = 1 AND last_number = 0 AND prefix = 'COM'
  ) INTO v_counter_initialized;

  IF NOT v_counter_initialized THEN
    RAISE EXCEPTION 'Purchase counter not initialized correctly';
  END IF;

  -- Verify RLS enabled on purchases
  SELECT rowsecurity INTO v_rls_purchases
  FROM pg_tables
  WHERE schemaname = 'public' AND tablename = 'purchases';

  IF NOT v_rls_purchases THEN
    RAISE EXCEPTION 'RLS not enabled on purchases table';
  END IF;

  -- Verify RLS enabled on purchase_items
  SELECT rowsecurity INTO v_rls_items
  FROM pg_tables
  WHERE schemaname = 'public' AND tablename = 'purchase_items';

  IF NOT v_rls_items THEN
    RAISE EXCEPTION 'RLS not enabled on purchase_items table';
  END IF;

  -- Verify RLS enabled on purchase_counter
  SELECT rowsecurity INTO v_rls_counter
  FROM pg_tables
  WHERE schemaname = 'public' AND tablename = 'purchase_counter';

  IF NOT v_rls_counter THEN
    RAISE EXCEPTION 'RLS not enabled on purchase_counter table';
  END IF;

  -- Verify updated_at trigger exists
  SELECT EXISTS (
    SELECT 1 FROM pg_trigger
    WHERE tgname = 'tr_purchases_updated_at'
  ) INTO v_has_updated_at_trigger;

  IF NOT v_has_updated_at_trigger THEN
    RAISE EXCEPTION 'updated_at trigger not created on purchases';
  END IF;

  -- Verify required columns on purchases
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'purchases' AND column_name = 'estado'
  ) THEN
    RAISE EXCEPTION 'purchases table missing estado column';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'purchases' AND column_name = 'factura_path'
  ) THEN
    RAISE EXCEPTION 'purchases table missing factura_path column';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'purchases' AND column_name = 'recibido_por'
  ) THEN
    RAISE EXCEPTION 'purchases table missing recibido_por column';
  END IF;

  -- Verify product snapshot columns on purchase_items
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'purchase_items' AND column_name = 'product_codigo'
  ) THEN
    RAISE EXCEPTION 'purchase_items missing product_codigo column';
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'purchase_items' AND column_name = 'costo_unitario'
  ) THEN
    RAISE EXCEPTION 'purchase_items missing costo_unitario column';
  END IF;

  -- Verify get_next_compra_number function exists
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc
    WHERE proname = 'get_next_compra_number'
  ) THEN
    RAISE EXCEPTION 'get_next_compra_number function not created';
  END IF;

  RAISE NOTICE 'Purchases schema verification passed: tables, enums, counter, RLS policies created successfully';
END $$;

-- ============================================================================
-- Summary of requirements addressed:
-- COM-01: purchases table with header information (proveedor, fecha_factura, total, notas)
-- COM-02: purchase_items with product snapshots and costo_unitario for margin analysis
-- COM-03: purchase_counter + get_next_compra_number() for gapless numbering
-- COM-04: factura_path NOT NULL ensures invoice photo/PDF required
-- COM-05: compra_estado ENUM with pendiente_recepcion -> recibido flow
-- COM-06: anulacion_justificacion required via constraint
--
-- Pending for future migrations:
-- COM-07: RPC for stock increment on reception confirmation
-- COM-08: RPC for stock reversal on anulacion
-- ============================================================================
