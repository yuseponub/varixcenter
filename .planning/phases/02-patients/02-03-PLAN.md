---
phase: 02-patients
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/validations/patient.ts
  - src/lib/queries/patients.ts
autonomous: true

must_haves:
  truths:
    - "Zod schema validates cedula as 6-10 digits"
    - "Zod schema requires emergency contact fields"
    - "Update schema omits cedula (cannot be modified)"
    - "Search query uses ILIKE for partial matching"
    - "Patient queries use typed Supabase client"
  artifacts:
    - path: "src/lib/validations/patient.ts"
      provides: "Zod schemas for patient validation"
      exports: ["patientSchema", "patientUpdateSchema", "PatientFormData"]
    - path: "src/lib/queries/patients.ts"
      provides: "Supabase query functions for patients"
      exports: ["searchPatients", "getPatientById", "getPatientTimeline"]
  key_links:
    - from: "src/lib/validations/patient.ts"
      to: "zod"
      via: "z.object import"
      pattern: "import.*z.*from.*zod"
    - from: "src/lib/queries/patients.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient import"
      pattern: "createClient.*supabase/server"
---

<objective>
Create shared Zod validation schemas and Supabase query functions for patient management

Purpose: Establishes a single source of truth for patient data validation (used by both forms and server actions) and encapsulates all database queries in reusable functions.
Output: Validation schemas and query functions ready for use in actions and components
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-patients/02-RESEARCH.md

# Supabase server client from Phase 1
@src/lib/supabase/server.ts

# TypeScript types (updated in 02-02)
@src/types/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas</name>
  <files>src/lib/validations/patient.ts</files>
  <action>
Create the directory if needed: `mkdir -p src/lib/validations`

Create file `src/lib/validations/patient.ts`:

```typescript
import { z } from 'zod'

/**
 * Colombian cedula format: 6-10 digits only
 * No check digit algorithm exists for CC (unlike NIT)
 */
const cedulaRegex = /^\d{6,10}$/

/**
 * Colombian phone: 10 digits (includes area code)
 * Example: 3001234567
 */
const phoneRegex = /^\d{10}$/

/**
 * Patient creation schema
 * Used by: Patient form, createPatient server action
 *
 * All messages in Spanish for Colombian users
 */
export const patientSchema = z.object({
  // Identification
  cedula: z
    .string()
    .min(1, 'La cedula es requerida')
    .regex(cedulaRegex, 'La cedula debe tener entre 6 y 10 digitos'),

  // Personal info
  nombre: z
    .string()
    .min(2, 'El nombre debe tener al menos 2 caracteres')
    .max(100, 'El nombre es muy largo'),

  apellido: z
    .string()
    .min(2, 'El apellido debe tener al menos 2 caracteres')
    .max(100, 'El apellido es muy largo'),

  celular: z
    .string()
    .min(1, 'El celular es requerido')
    .regex(phoneRegex, 'El celular debe tener 10 digitos'),

  email: z
    .string()
    .email('El email no es valido')
    .max(255, 'El email es muy largo')
    .optional()
    .or(z.literal('')),

  fecha_nacimiento: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Formato debe ser YYYY-MM-DD')
    .optional()
    .or(z.literal('')),

  direccion: z
    .string()
    .max(200, 'La direccion es muy larga')
    .optional()
    .or(z.literal('')),

  // Emergency contact (REQUIRED per PAT-04)
  contacto_emergencia_nombre: z
    .string()
    .min(2, 'El nombre del contacto de emergencia es requerido')
    .max(100, 'El nombre es muy largo'),

  contacto_emergencia_telefono: z
    .string()
    .min(1, 'El telefono de emergencia es requerido')
    .regex(phoneRegex, 'El telefono debe tener 10 digitos'),

  contacto_emergencia_parentesco: z
    .string()
    .min(2, 'El parentesco es requerido')
    .max(50, 'El parentesco es muy largo'),
})

/**
 * Patient update schema
 * IMPORTANT: cedula is intentionally OMITTED - it cannot be modified after creation
 * The database trigger will also reject cedula changes as a second layer of protection
 */
export const patientUpdateSchema = patientSchema.omit({ cedula: true })

/**
 * TypeScript types inferred from schemas
 */
export type PatientFormData = z.infer<typeof patientSchema>
export type PatientUpdateData = z.infer<typeof patientUpdateSchema>

/**
 * Search query validation (for URL params)
 */
export const patientSearchSchema = z.object({
  q: z.string().max(100).optional(),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
})

export type PatientSearchParams = z.infer<typeof patientSearchSchema>
```

Key points:
1. cedula regex is `/^\d{6,10}$/` - Colombian CC is just digits, no check digit
2. All error messages in Spanish
3. patientUpdateSchema uses `.omit({ cedula: true })` for type-safe immutability
4. Optional fields use `.optional().or(z.literal(''))` to handle empty strings from forms
5. Phone validation is simple 10-digit regex (no need for libphonenumber-js)
  </action>
  <verify>
Run `cat src/lib/validations/patient.ts | grep -E "(export const|cedulaRegex|omit.*cedula)"` - should show patientSchema, patientUpdateSchema exports and cedula-related patterns.
  </verify>
  <done>
Zod schemas created with cedula validation, Spanish messages, and update schema omitting cedula
  </done>
</task>

<task type="auto">
  <name>Task 2: Create patient query functions</name>
  <files>src/lib/queries/patients.ts</files>
  <action>
Create the directory if needed: `mkdir -p src/lib/queries`

Create file `src/lib/queries/patients.ts`:

```typescript
import { createClient } from '@/lib/supabase/server'

/**
 * Search patients by cedula, nombre, apellido, or celular
 * Uses ILIKE for case-insensitive partial matching
 *
 * @param query - Search term (partial match on multiple fields)
 * @param limit - Max results to return (default 50)
 * @returns Matching patients sorted by apellido
 */
export async function searchPatients(query: string, limit = 50) {
  const supabase = await createClient()

  // If empty query, return recent patients
  if (!query.trim()) {
    const { data, error } = await supabase
      .from('patients')
      .select('id, cedula, nombre, apellido, celular, created_at')
      .order('created_at', { ascending: false })
      .limit(limit)

    if (error) throw error
    return data
  }

  const searchPattern = `%${query.trim()}%`

  const { data, error } = await supabase
    .from('patients')
    .select('id, cedula, nombre, apellido, celular, created_at')
    .or(
      `cedula.ilike.${searchPattern},nombre.ilike.${searchPattern},apellido.ilike.${searchPattern},celular.ilike.${searchPattern}`
    )
    .order('apellido', { ascending: true })
    .limit(limit)

  if (error) throw error
  return data
}

/**
 * Get a single patient by ID with all fields
 *
 * @param id - Patient UUID
 * @returns Full patient record or null if not found
 */
export async function getPatientById(id: string) {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('patients')
    .select('*')
    .eq('id', id)
    .single()

  if (error) {
    if (error.code === 'PGRST116') {
      // Not found
      return null
    }
    throw error
  }

  return data
}

/**
 * Get patient timeline from audit_log
 * Shows history of changes to the patient record
 *
 * Note: In future phases, this will expand to include
 * payments, appointments, and medical records
 *
 * @param patientId - Patient UUID
 * @param limit - Max events to return (default 20)
 * @returns Timeline events sorted by most recent first
 */
export async function getPatientTimeline(patientId: string, limit = 20) {
  const supabase = await createClient()

  // For Phase 2, timeline only shows patient record changes
  // Future phases will add: payments, appointments, procedures
  const { data, error } = await supabase
    .from('audit_log')
    .select('id, action, changed_fields, changed_at, old_data, new_data')
    .eq('table_name', 'patients')
    .eq('record_id', patientId)
    .order('changed_at', { ascending: false })
    .limit(limit)

  if (error) throw error

  // Transform audit log entries into timeline events
  return data.map((entry) => ({
    id: entry.id,
    type: 'patient_record' as const,
    action: entry.action,
    changedFields: entry.changed_fields,
    timestamp: entry.changed_at,
    details: getTimelineEventDetails(entry),
  }))
}

/**
 * Helper to generate human-readable timeline event descriptions
 */
function getTimelineEventDetails(entry: {
  action: string
  changed_fields: string[] | null
  old_data: unknown
  new_data: unknown
}): string {
  switch (entry.action) {
    case 'INSERT':
      return 'Paciente registrado en el sistema'
    case 'UPDATE':
      if (entry.changed_fields?.length) {
        return `Datos actualizados: ${entry.changed_fields.join(', ')}`
      }
      return 'Datos del paciente actualizados'
    case 'DELETE':
      return 'Paciente eliminado del sistema'
    default:
      return 'Cambio en registro'
  }
}

/**
 * Check if a cedula already exists
 * Used before creating a patient to provide better UX
 *
 * @param cedula - Cedula to check
 * @returns true if cedula exists, false otherwise
 */
export async function cedulaExists(cedula: string): Promise<boolean> {
  const supabase = await createClient()

  const { count, error } = await supabase
    .from('patients')
    .select('id', { count: 'exact', head: true })
    .eq('cedula', cedula)

  if (error) throw error
  return (count ?? 0) > 0
}

/**
 * Get paginated list of patients
 *
 * @param page - Page number (1-indexed)
 * @param limit - Items per page
 * @returns Paginated patients with total count
 */
export async function getPatientsPage(page = 1, limit = 20) {
  const supabase = await createClient()
  const offset = (page - 1) * limit

  // Get total count
  const { count, error: countError } = await supabase
    .from('patients')
    .select('id', { count: 'exact', head: true })

  if (countError) throw countError

  // Get page data
  const { data, error } = await supabase
    .from('patients')
    .select('id, cedula, nombre, apellido, celular, created_at')
    .order('apellido', { ascending: true })
    .range(offset, offset + limit - 1)

  if (error) throw error

  return {
    data,
    pagination: {
      page,
      limit,
      total: count ?? 0,
      totalPages: Math.ceil((count ?? 0) / limit),
    },
  }
}
```

Key points:
1. All functions use `createClient()` from Phase 1 server client
2. `searchPatients` uses ILIKE with `.or()` for multi-field search
3. `getPatientTimeline` queries audit_log and transforms to readable events
4. Error handling distinguishes "not found" from actual errors
5. `cedulaExists` for pre-submission UX feedback
6. `getPatientsPage` for paginated table display
  </action>
  <verify>
Run `cat src/lib/queries/patients.ts | grep -E "(export async function|ilike|audit_log)"` - should show all exported functions and the search/audit patterns.
  </verify>
  <done>
Patient query functions created with search, detail, timeline, and pagination support
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Both files exist and export correctly
2. `npm run build` should pass (TypeScript compiles)
3. No import errors in either file
</verification>

<success_criteria>
- patientSchema validates cedula format (6-10 digits)
- patientUpdateSchema omits cedula field
- All validation messages are in Spanish
- searchPatients uses ILIKE with .or() for multi-field search
- getPatientTimeline queries audit_log for patient events
- All query functions use typed Supabase client
</success_criteria>

<output>
After completion, create `.planning/phases/02-patients/02-03-SUMMARY.md`
</output>
