-- Migration: 009_payments_tables.sql
-- Purpose: Payments, payment items, payment methods tables with gapless invoice numbering
-- Phase: 04-payments-core, Plan: 01
-- Created: 2026-01-24
-- NOTE: This is the CORE VALUE - immutable payment records with mandatory evidence

-- ============================================
-- 1. ENUM TYPES
-- ============================================

-- Payment status: only 'activo' -> 'anulado' transition allowed
CREATE TYPE public.payment_status AS ENUM ('activo', 'anulado');

COMMENT ON TYPE public.payment_status IS 'Estado del pago: activo (normal) o anulado (requiere justificacion)';

-- Payment method types
CREATE TYPE public.payment_method_type AS ENUM ('efectivo', 'tarjeta', 'transferencia', 'nequi');

COMMENT ON TYPE public.payment_method_type IS 'Tipos de metodos de pago aceptados';

-- ============================================
-- 2. INVOICE COUNTER TABLE (GAPLESS NUMBERING)
-- ============================================

-- Single-row table for gapless sequential invoice numbers
-- PostgreSQL sequences have gaps on rollback; this counter ensures gapless numbering
CREATE TABLE public.invoice_counter (
  id INTEGER PRIMARY KEY DEFAULT 1,
  last_number BIGINT NOT NULL DEFAULT 0,
  prefix VARCHAR(10) NOT NULL DEFAULT 'FAC',

  -- Single-row enforcement: only id=1 allowed
  CONSTRAINT single_row_enforcement CHECK (id = 1)
);

COMMENT ON TABLE public.invoice_counter IS 'Contador de facturas con numeracion secuencial sin gaps - solo una fila permitida';
COMMENT ON COLUMN public.invoice_counter.last_number IS 'Ultimo numero de factura generado';
COMMENT ON COLUMN public.invoice_counter.prefix IS 'Prefijo para el numero de factura (ej: FAC)';

-- Initialize counter with single row
INSERT INTO public.invoice_counter (id, last_number, prefix) VALUES (1, 0, 'FAC');

-- ============================================
-- 3. INVOICE COUNTER PROTECTION TRIGGER
-- ============================================

-- Prevent DELETE and multiple INSERTs on invoice_counter
CREATE OR REPLACE FUNCTION public.protect_invoice_counter()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'No se puede eliminar el contador de facturas';
  END IF;

  IF TG_OP = 'INSERT' THEN
    IF (SELECT COUNT(*) FROM public.invoice_counter) > 0 THEN
      RAISE EXCEPTION 'Solo puede existir un contador de facturas';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

CREATE TRIGGER tr_protect_invoice_counter
  BEFORE INSERT OR DELETE ON public.invoice_counter
  FOR EACH ROW
  EXECUTE FUNCTION public.protect_invoice_counter();

-- ============================================
-- 4. GET NEXT INVOICE NUMBER FUNCTION
-- ============================================

-- Atomically get next invoice number with exclusive row lock
-- CRITICAL: Called within transaction, uses FOR UPDATE to prevent race conditions
CREATE OR REPLACE FUNCTION public.get_next_invoice_number()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
  next_num BIGINT;
  prefix_val VARCHAR(10);
BEGIN
  -- Lock the counter row exclusively (FOR UPDATE)
  -- This prevents concurrent transactions from getting the same number
  SELECT last_number + 1, prefix
  INTO next_num, prefix_val
  FROM public.invoice_counter
  WHERE id = 1
  FOR UPDATE;

  -- Update the counter atomically
  UPDATE public.invoice_counter
  SET last_number = next_num
  WHERE id = 1;

  -- Return formatted invoice number: FAC-000001
  RETURN prefix_val || '-' || LPAD(next_num::text, 6, '0');
END;
$$;

COMMENT ON FUNCTION public.get_next_invoice_number() IS 'Genera el siguiente numero de factura con bloqueo exclusivo para evitar gaps';

-- ============================================
-- 5. PAYMENTS TABLE
-- ============================================

CREATE TABLE public.payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Patient reference
  patient_id UUID NOT NULL REFERENCES public.patients(id) ON DELETE RESTRICT,

  -- Invoice number (generated by get_next_invoice_number())
  numero_factura VARCHAR(20) NOT NULL UNIQUE,

  -- Totals
  subtotal DECIMAL(12,2) NOT NULL,
  descuento DECIMAL(12,2) NOT NULL DEFAULT 0,
  descuento_justificacion TEXT,
  total DECIMAL(12,2) NOT NULL,

  -- Status (only 'activo' -> 'anulado' allowed, enforced by trigger in 010)
  estado public.payment_status NOT NULL DEFAULT 'activo',

  -- Anulacion fields (populated when estado changes to 'anulado')
  anulado_por UUID REFERENCES auth.users(id),
  anulado_at TIMESTAMPTZ,
  anulacion_justificacion TEXT,

  -- Audit (NO updated_at - payments are immutable)
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- ============================================
  -- CONSTRAINTS
  -- ============================================

  -- Prices must be non-negative
  CONSTRAINT descuento_positive CHECK (descuento >= 0),
  CONSTRAINT total_positive CHECK (total >= 0),

  -- Discount requires justification (anti-fraud)
  CONSTRAINT descuento_requires_justificacion CHECK (
    descuento = 0 OR descuento_justificacion IS NOT NULL
  )
);

-- Table comments
COMMENT ON TABLE public.payments IS 'Pagos inmutables - solo se permite anulacion con justificacion obligatoria';
COMMENT ON COLUMN public.payments.numero_factura IS 'Numero de factura secuencial sin gaps (FAC-000001)';
COMMENT ON COLUMN public.payments.descuento_justificacion IS 'Obligatorio si descuento > 0';
COMMENT ON COLUMN public.payments.estado IS 'Solo transicion activo -> anulado permitida';
COMMENT ON COLUMN public.payments.anulacion_justificacion IS 'Obligatorio al anular - explica razon de la anulacion';

-- ============================================
-- 6. PAYMENT_ITEMS TABLE
-- ============================================

CREATE TABLE public.payment_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Payment reference (RESTRICT delete to protect data integrity)
  payment_id UUID NOT NULL REFERENCES public.payments(id) ON DELETE RESTRICT,

  -- Service reference (keeps link for analytics)
  service_id UUID NOT NULL REFERENCES public.services(id) ON DELETE RESTRICT,

  -- Snapshot of service at time of payment (IMMUTABLE - even if service changes later)
  service_name VARCHAR(100) NOT NULL,
  unit_price DECIMAL(12,2) NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 1,
  subtotal DECIMAL(12,2) NOT NULL,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- ============================================
  -- CONSTRAINTS
  -- ============================================

  CONSTRAINT quantity_positive CHECK (quantity > 0),
  CONSTRAINT unit_price_positive CHECK (unit_price >= 0)
);

-- Table comments
COMMENT ON TABLE public.payment_items IS 'Items del pago con snapshot del servicio al momento de la venta';
COMMENT ON COLUMN public.payment_items.service_name IS 'Nombre del servicio al momento del pago (snapshot inmutable)';
COMMENT ON COLUMN public.payment_items.unit_price IS 'Precio unitario al momento del pago (snapshot inmutable)';

-- ============================================
-- 7. PAYMENT_METHODS TABLE
-- ============================================

CREATE TABLE public.payment_methods (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Payment reference (RESTRICT delete to protect data integrity)
  payment_id UUID NOT NULL REFERENCES public.payments(id) ON DELETE RESTRICT,

  -- Method and amount
  metodo public.payment_method_type NOT NULL,
  monto DECIMAL(12,2) NOT NULL,

  -- Receipt photo path (Supabase Storage)
  -- CRITICAL: Required for electronic payments (tarjeta, transferencia, nequi)
  comprobante_path TEXT,

  -- Audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- ============================================
  -- CONSTRAINTS
  -- ============================================

  -- Amount must be positive
  CONSTRAINT monto_positive CHECK (monto > 0),

  -- CRITICAL: Electronic payments require receipt photo (anti-fraud)
  CONSTRAINT comprobante_required_for_electronic CHECK (
    metodo = 'efectivo' OR comprobante_path IS NOT NULL
  )
);

-- Table comments
COMMENT ON TABLE public.payment_methods IS 'Metodos de pago usados - soporta pagos divididos';
COMMENT ON COLUMN public.payment_methods.comprobante_path IS 'Ruta en Supabase Storage - OBLIGATORIO para pagos electronicos';
COMMENT ON CONSTRAINT comprobante_required_for_electronic ON public.payment_methods IS 'Pagos electronicos requieren foto de comprobante obligatoria';

-- ============================================
-- 8. INDEXES
-- ============================================

-- Payments indexes
CREATE INDEX idx_payments_patient ON public.payments(patient_id);
CREATE INDEX idx_payments_estado ON public.payments(estado);
CREATE INDEX idx_payments_created_at ON public.payments(created_at DESC);
CREATE INDEX idx_payments_numero_factura ON public.payments(numero_factura);

-- Payment items indexes
CREATE INDEX idx_payment_items_payment ON public.payment_items(payment_id);
CREATE INDEX idx_payment_items_service ON public.payment_items(service_id);

-- Payment methods indexes
CREATE INDEX idx_payment_methods_payment ON public.payment_methods(payment_id);

-- ============================================
-- 9. ROW LEVEL SECURITY
-- ============================================

-- PAYMENTS TABLE RLS
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

-- All authenticated can view payments
CREATE POLICY "Staff can view payments"
  ON public.payments FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico', 'enfermera', 'secretaria')
    )
  );

-- All authenticated can create payments
CREATE POLICY "Staff can create payments"
  ON public.payments FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico', 'enfermera', 'secretaria')
    )
  );

-- NO UPDATE policy at RLS level (trigger in 010 will handle anulacion only)
-- NO DELETE policy (payments cannot be deleted, only anulados)

-- PAYMENT_ITEMS TABLE RLS
ALTER TABLE public.payment_items ENABLE ROW LEVEL SECURITY;

-- All authenticated can view payment items
CREATE POLICY "Staff can view payment items"
  ON public.payment_items FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico', 'enfermera', 'secretaria')
    )
  );

-- All authenticated can create payment items
CREATE POLICY "Staff can create payment items"
  ON public.payment_items FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico', 'enfermera', 'secretaria')
    )
  );

-- NO UPDATE policy (payment items are immutable)
-- NO DELETE policy (payment items cannot be deleted)

-- PAYMENT_METHODS TABLE RLS
ALTER TABLE public.payment_methods ENABLE ROW LEVEL SECURITY;

-- All authenticated can view payment methods
CREATE POLICY "Staff can view payment methods"
  ON public.payment_methods FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico', 'enfermera', 'secretaria')
    )
  );

-- All authenticated can create payment methods
CREATE POLICY "Staff can create payment methods"
  ON public.payment_methods FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role IN ('admin', 'medico', 'enfermera', 'secretaria')
    )
  );

-- NO UPDATE policy (payment methods are immutable)
-- NO DELETE policy (payment methods cannot be deleted)

-- INVOICE_COUNTER TABLE RLS (admin only)
ALTER TABLE public.invoice_counter ENABLE ROW LEVEL SECURITY;

-- Only service role and admin can access counter (used by functions)
CREATE POLICY "Admin can view invoice counter"
  ON public.invoice_counter FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_id = auth.uid()
      AND role = 'admin'
    )
  );

-- Allow UPDATE for invoice number generation (via function)
CREATE POLICY "Allow counter update"
  ON public.invoice_counter FOR UPDATE
  TO authenticated
  WITH CHECK (true);

-- ============================================
-- 10. GRANT PERMISSIONS
-- ============================================

GRANT SELECT, INSERT ON public.payments TO authenticated;
GRANT SELECT, INSERT ON public.payment_items TO authenticated;
GRANT SELECT, INSERT ON public.payment_methods TO authenticated;
GRANT SELECT, UPDATE ON public.invoice_counter TO authenticated;

-- ============================================
-- 11. VERIFICATION
-- ============================================

-- Verify RLS is enabled on all tables
DO $$
BEGIN
  -- Check payments
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'payments' AND rowsecurity = true
  ) THEN
    RAISE EXCEPTION 'RLS not enabled on payments table';
  END IF;

  -- Check payment_items
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'payment_items' AND rowsecurity = true
  ) THEN
    RAISE EXCEPTION 'RLS not enabled on payment_items table';
  END IF;

  -- Check payment_methods
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'payment_methods' AND rowsecurity = true
  ) THEN
    RAISE EXCEPTION 'RLS not enabled on payment_methods table';
  END IF;

  -- Check invoice_counter
  IF NOT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public' AND tablename = 'invoice_counter' AND rowsecurity = true
  ) THEN
    RAISE EXCEPTION 'RLS not enabled on invoice_counter table';
  END IF;
END;
$$;

-- Verify invoice counter has exactly one row
DO $$
BEGIN
  IF (SELECT COUNT(*) FROM public.invoice_counter) != 1 THEN
    RAISE EXCEPTION 'Invoice counter must have exactly one row';
  END IF;
END;
$$;
