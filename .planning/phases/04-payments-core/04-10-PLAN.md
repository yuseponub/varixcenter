---
phase: 04-payments-core
plan: 10
type: execute
wave: 4
depends_on: ["04-08", "04-09"]
files_modified:
  - src/components/payments/payment-form.tsx
  - src/app/(protected)/pagos/nuevo/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a payment with multiple services"
    - "User can pay with multiple methods"
    - "Electronic payments require and show comprobante upload"
    - "Descuento requires justification"
  artifacts:
    - path: "src/components/payments/payment-form.tsx"
      provides: "Complete payment form with all sections"
      contains: "PaymentForm"
    - path: "src/app/(protected)/pagos/nuevo/page.tsx"
      provides: "New payment page"
      contains: "Nuevo Pago"
  key_links:
    - from: "payment-form.tsx"
      to: "pagos/actions.ts"
      via: "useActionState"
      pattern: "createPayment"
---

<objective>
Create the complete payment form and new payment page.

Purpose: Allow users to register payments with services, payment methods, and optional discounts.
Output: Payment form component and new payment page
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-payments-core/04-08-SUMMARY.md
@.planning/phases/04-payments-core/04-09-SUMMARY.md

Reference existing patterns:
@src/components/patients/patient-form.tsx
@src/app/(protected)/pacientes/nuevo/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create complete payment form component</name>
  <files>src/components/payments/payment-form.tsx</files>
  <action>
Create src/components/payments/payment-form.tsx with:

```typescript
'use client'

import { useActionState, useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Loader2 } from 'lucide-react'
import { toast } from 'sonner'
import { ServiceSelector } from './service-selector'
import { PaymentMethodForm } from './payment-method-form'
import { PaymentSummary } from './payment-summary'
import { createPayment, type PaymentActionState } from '@/app/(protected)/pagos/actions'
import type { ServiceOption } from '@/types/services'
import type { PaymentItemInput, PaymentMethodInput } from '@/types/payments'

interface Patient {
  id: string
  cedula: string
  nombre: string
  apellido: string
}

interface PaymentFormProps {
  services: ServiceOption[]
  patients: Patient[]
  defaultPatientId?: string
}

export function PaymentForm({ services, patients, defaultPatientId }: PaymentFormProps) {
  const router = useRouter()
  const [state, formAction, isPending] = useActionState<PaymentActionState | null, FormData>(
    createPayment,
    null
  )

  // Form state
  const [patientId, setPatientId] = useState(defaultPatientId || '')
  const [items, setItems] = useState<PaymentItemInput[]>([])
  const [methods, setMethods] = useState<PaymentMethodInput[]>([{
    metodo: 'efectivo',
    monto: 0,
    comprobante_path: null
  }])
  const [descuento, setDescuento] = useState(0)
  const [descuentoJustificacion, setDescuentoJustificacion] = useState('')

  // Calculated values
  const subtotal = items.reduce((sum, item) => sum + item.unit_price * item.quantity, 0)
  const total = subtotal - descuento
  const methodsTotal = methods.reduce((sum, m) => sum + m.monto, 0)
  const isBalanced = Math.abs(total - methodsTotal) < 0.01

  // Update first method amount when items change
  useEffect(() => {
    if (methods.length === 1 && methods[0].monto === 0 && total > 0) {
      setMethods([{ ...methods[0], monto: total }])
    }
  }, [total])

  // Handle success/error
  useEffect(() => {
    if (state?.success && state.data) {
      toast.success(`Pago registrado: ${state.data.numero_factura}`)
      router.push(`/pagos/${state.data.id}`)
    } else if (state?.error) {
      toast.error(state.error)
    }
  }, [state, router])

  // Validation
  const canSubmit =
    patientId &&
    items.length > 0 &&
    methods.length > 0 &&
    isBalanced &&
    (descuento === 0 || descuentoJustificacion.length >= 5) &&
    methods.every(m => m.metodo === 'efectivo' || m.comprobante_path)

  const handleSubmit = (formData: FormData) => {
    // Add JSON data to form
    formData.set('patient_id', patientId)
    formData.set('items', JSON.stringify(items))
    formData.set('methods', JSON.stringify(methods))
    formData.set('descuento', descuento.toString())
    formData.set('descuento_justificacion', descuentoJustificacion)

    formAction(formData)
  }

  return (
    <form action={handleSubmit} className="space-y-6">
      {/* Patient selection */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Paciente</CardTitle>
        </CardHeader>
        <CardContent>
          <Select value={patientId} onValueChange={setPatientId} disabled={isPending}>
            <SelectTrigger>
              <SelectValue placeholder="Seleccionar paciente..." />
            </SelectTrigger>
            <SelectContent>
              {patients.map(p => (
                <SelectItem key={p.id} value={p.id}>
                  {p.cedula} - {p.nombre} {p.apellido}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          {state?.errors?.patient_id && (
            <p className="text-sm text-red-500 mt-1">{state.errors.patient_id[0]}</p>
          )}
        </CardContent>
      </Card>

      {/* Services */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Servicios</CardTitle>
        </CardHeader>
        <CardContent>
          <ServiceSelector
            services={services}
            items={items}
            onChange={setItems}
            disabled={isPending}
          />
          {state?.errors?.items && (
            <p className="text-sm text-red-500 mt-2">{state.errors.items[0]}</p>
          )}
        </CardContent>
      </Card>

      {/* Descuento */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Descuento (opcional)</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="descuento">Monto del descuento</Label>
              <Input
                id="descuento"
                type="number"
                value={descuento || ''}
                onChange={e => setDescuento(parseFloat(e.target.value) || 0)}
                disabled={isPending}
                min={0}
                max={subtotal}
              />
            </div>
          </div>
          {descuento > 0 && (
            <div className="space-y-2">
              <Label htmlFor="descuento_justificacion" className="after:content-['*'] after:ml-0.5 after:text-red-500">
                Justificacion del descuento
              </Label>
              <Textarea
                id="descuento_justificacion"
                value={descuentoJustificacion}
                onChange={e => setDescuentoJustificacion(e.target.value)}
                disabled={isPending}
                placeholder="Explique la razon del descuento (minimo 5 caracteres)"
                rows={2}
              />
              {descuentoJustificacion.length < 5 && descuentoJustificacion.length > 0 && (
                <p className="text-sm text-amber-600">Minimo 5 caracteres</p>
              )}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Payment methods */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Metodos de Pago</CardTitle>
        </CardHeader>
        <CardContent>
          <PaymentMethodForm
            methods={methods}
            onChange={setMethods}
            totalRequired={total}
            disabled={isPending}
          />
          {state?.errors?.methods && (
            <p className="text-sm text-red-500 mt-2">{state.errors.methods[0]}</p>
          )}
        </CardContent>
      </Card>

      {/* Summary */}
      {items.length > 0 && (
        <PaymentSummary
          items={items}
          methods={methods}
          descuento={descuento}
          descuentoJustificacion={descuentoJustificacion || null}
        />
      )}

      {/* Submit */}
      <div className="flex gap-4">
        <Button
          type="button"
          variant="outline"
          onClick={() => router.back()}
          disabled={isPending}
        >
          Cancelar
        </Button>
        <Button type="submit" disabled={isPending || !canSubmit}>
          {isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
          Registrar Pago
        </Button>
      </div>

      {/* Global error */}
      {state?.error && !state.errors && (
        <p className="text-sm text-red-500">{state.error}</p>
      )}
    </form>
  )
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit src/components/payments/payment-form.tsx 2>&1 | head -20
```
  </verify>
  <done>src/components/payments/payment-form.tsx exists with PaymentForm that composes ServiceSelector, PaymentMethodForm, PaymentSummary, handles descuento with justification, validates all fields before submit</done>
</task>

<task type="auto">
  <name>Task 2: Create new payment page</name>
  <files>src/app/(protected)/pagos/nuevo/page.tsx</files>
  <action>
Create src/app/(protected)/pagos/nuevo/page.tsx with:

```typescript
import { Suspense } from 'react'
import { createClient } from '@/lib/supabase/server'
import { getActiveServices } from '@/lib/queries/services'
import { PaymentForm } from '@/components/payments/payment-form'
import {
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
} from '@/components/ui/breadcrumb'

interface NewPaymentPageProps {
  searchParams: Promise<{ patient?: string }>
}

async function getPatients() {
  const supabase = await createClient()
  const { data } = await supabase
    .from('patients')
    .select('id, cedula, nombre, apellido')
    .order('nombre')

  return data || []
}

export default async function NewPaymentPage({ searchParams }: NewPaymentPageProps) {
  const params = await searchParams
  const [services, patients] = await Promise.all([
    getActiveServices(),
    getPatients()
  ])

  return (
    <div className="space-y-6">
      {/* Breadcrumb */}
      <Breadcrumb>
        <BreadcrumbList>
          <BreadcrumbItem>
            <BreadcrumbLink href="/dashboard">Inicio</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbSeparator />
          <BreadcrumbItem>
            <BreadcrumbLink href="/pagos">Pagos</BreadcrumbLink>
          </BreadcrumbItem>
          <BreadcrumbSeparator />
          <BreadcrumbItem>
            <BreadcrumbPage>Nuevo Pago</BreadcrumbPage>
          </BreadcrumbItem>
        </BreadcrumbList>
      </Breadcrumb>

      {/* Header */}
      <div>
        <h1 className="text-2xl font-bold tracking-tight">Nuevo Pago</h1>
        <p className="text-muted-foreground">
          Registre un nuevo pago seleccionando paciente, servicios y metodo de pago.
        </p>
      </div>

      {/* Form */}
      <Suspense fallback={<div>Cargando...</div>}>
        <PaymentForm
          services={services}
          patients={patients}
          defaultPatientId={params.patient}
        />
      </Suspense>
    </div>
  )
}
```

Note: Create the pagos/nuevo directory structure.
  </action>
  <verify>
```bash
mkdir -p src/app/\(protected\)/pagos/nuevo
npx tsc --noEmit src/app/\(protected\)/pagos/nuevo/page.tsx 2>&1 | head -20
```
  </verify>
  <done>src/app/(protected)/pagos/nuevo/page.tsx exists with NewPaymentPage that fetches services and patients, renders PaymentForm with optional default patient from query param</done>
</task>

</tasks>

<verification>
1. Both files compile without TypeScript errors
2. PaymentForm validates all requirements before enabling submit
3. PaymentForm shows descuento justification only when descuento > 0
4. New payment page fetches services and patients in parallel
5. Page accepts ?patient=uuid query param for pre-selection
6. Form redirects to payment detail page on success
</verification>

<success_criteria>
- src/components/payments/payment-form.tsx: Complete form with all validations
- src/app/(protected)/pagos/nuevo/page.tsx: Page with breadcrumb and form
- Descuento requires 5+ char justification
- Electronic payments require comprobante
- Balance must match before submit
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments-core/04-10-SUMMARY.md`
</output>
