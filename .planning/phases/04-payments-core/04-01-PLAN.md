---
phase: 04-payments-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/008_services_catalog.sql
  - supabase/migrations/009_payments_tables.sql
autonomous: true

must_haves:
  truths:
    - "Services table exists with RLS policies"
    - "Payments tables exist with proper foreign keys"
    - "Invoice counter table exists with single-row enforcement"
  artifacts:
    - path: "supabase/migrations/008_services_catalog.sql"
      provides: "Services catalog schema with variable price support"
      contains: "CREATE TABLE public.services"
    - path: "supabase/migrations/009_payments_tables.sql"
      provides: "Payment tables and invoice counter"
      contains: "CREATE TABLE public.payments"
  key_links:
    - from: "payments"
      to: "patients"
      via: "patient_id FK"
      pattern: "REFERENCES public.patients"
    - from: "payment_items"
      to: "services"
      via: "service_id FK"
      pattern: "REFERENCES public.services"
---

<objective>
Create the core database schema for services catalog and payments.

Purpose: Establish the data foundation for immutable payment records with service catalog pricing and split payment support.
Output: Two SQL migrations - services catalog (008) and payments tables (009)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-payments-core/04-RESEARCH.md

Reference existing patterns:
@supabase/migrations/006_patients_table.sql
@supabase/migrations/007_appointments.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create services catalog migration (008)</name>
  <files>supabase/migrations/008_services_catalog.sql</files>
  <action>
Create migration 008_services_catalog.sql with:

1. **services table:**
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - nombre: VARCHAR(100) NOT NULL UNIQUE
   - descripcion: TEXT
   - precio_base: DECIMAL(12,2) NOT NULL (base price)
   - precio_variable: BOOLEAN NOT NULL DEFAULT false (if true, price can be adjusted at payment time)
   - precio_minimo: DECIMAL(12,2) (for variable: minimum allowed)
   - precio_maximo: DECIMAL(12,2) (for variable: maximum allowed)
   - activo: BOOLEAN NOT NULL DEFAULT true (soft delete)
   - created_at: TIMESTAMPTZ NOT NULL DEFAULT now()
   - updated_at: TIMESTAMPTZ NOT NULL DEFAULT now()
   - created_by: UUID REFERENCES auth.users(id)

2. **Constraints:**
   - CHECK: precio_base >= 0
   - CHECK: precio_variable = false OR (precio_minimo IS NOT NULL AND precio_maximo IS NOT NULL)
   - CHECK: precio_minimo <= precio_base AND precio_base <= precio_maximo (when variable)

3. **RLS policies:**
   - SELECT: All authenticated users (any role can see service catalog)
   - INSERT: Admin only (crear servicios)
   - UPDATE: Admin only (editar servicios)
   - DELETE: None (use activo = false for soft delete)

4. **Audit trigger:**
   - Use existing tr_audit pattern from 004_audit_user_roles.sql
   - Log all INSERT/UPDATE to audit_log

5. **Index:**
   - CREATE INDEX idx_services_activo ON services(activo) WHERE activo = true

6. **Seed data (optional, commented):**
   - Example services: "Consulta inicial", "Escleroterapia", "Doppler venoso"
  </action>
  <verify>
```bash
# Check migration syntax
cat supabase/migrations/008_services_catalog.sql | grep -E "CREATE TABLE|POLICY|TRIGGER"
```
  </verify>
  <done>Migration 008 exists with services table, RLS policies (SELECT for all, INSERT/UPDATE for admin), audit trigger, and variable price constraints</done>
</task>

<task type="auto">
  <name>Task 2: Create payments tables migration (009)</name>
  <files>supabase/migrations/009_payments_tables.sql</files>
  <action>
Create migration 009_payments_tables.sql with:

1. **payment_status enum:**
   - CREATE TYPE payment_status AS ENUM ('activo', 'anulado')

2. **payment_method_type enum:**
   - CREATE TYPE payment_method_type AS ENUM ('efectivo', 'tarjeta', 'transferencia', 'nequi')

3. **invoice_counter table (CRITICAL for gapless numbering):**
   - id: INTEGER PRIMARY KEY DEFAULT 1 CHECK (id = 1) -- single row enforcement
   - last_number: BIGINT NOT NULL DEFAULT 0
   - prefix: VARCHAR(10) NOT NULL DEFAULT 'FAC'
   - INSERT single row: INSERT INTO invoice_counter (last_number, prefix) VALUES (0, 'FAC');

4. **Trigger to protect invoice_counter:**
   - Prevent DELETE always
   - Prevent INSERT if row exists
   - Allow only UPDATE to last_number

5. **get_next_invoice_number() function:**
   - Lock row with FOR UPDATE
   - Increment last_number
   - Return formatted: prefix || '-' || LPAD(next_num::text, 6, '0')
   - Example: FAC-000001

6. **payments table:**
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - patient_id: UUID NOT NULL REFERENCES patients(id)
   - numero_factura: VARCHAR(20) NOT NULL UNIQUE
   - subtotal: DECIMAL(12,2) NOT NULL
   - descuento: DECIMAL(12,2) NOT NULL DEFAULT 0
   - descuento_justificacion: TEXT (required if descuento > 0)
   - total: DECIMAL(12,2) NOT NULL
   - estado: payment_status NOT NULL DEFAULT 'activo'
   - anulado_por: UUID REFERENCES auth.users(id)
   - anulado_at: TIMESTAMPTZ
   - anulacion_justificacion: TEXT
   - created_by: UUID NOT NULL REFERENCES auth.users(id)
   - created_at: TIMESTAMPTZ NOT NULL DEFAULT now()
   - CHECK: descuento >= 0
   - CHECK: total >= 0
   - CHECK: descuento = 0 OR descuento_justificacion IS NOT NULL

7. **payment_items table:**
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - payment_id: UUID NOT NULL REFERENCES payments(id) ON DELETE RESTRICT
   - service_id: UUID NOT NULL REFERENCES services(id)
   - service_name: VARCHAR(100) NOT NULL (snapshot)
   - unit_price: DECIMAL(12,2) NOT NULL (snapshot)
   - quantity: INTEGER NOT NULL DEFAULT 1
   - subtotal: DECIMAL(12,2) NOT NULL
   - created_at: TIMESTAMPTZ NOT NULL DEFAULT now()
   - CHECK: quantity > 0
   - CHECK: unit_price >= 0

8. **payment_methods table:**
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - payment_id: UUID NOT NULL REFERENCES payments(id) ON DELETE RESTRICT
   - metodo: payment_method_type NOT NULL
   - monto: DECIMAL(12,2) NOT NULL
   - comprobante_path: TEXT
   - created_at: TIMESTAMPTZ NOT NULL DEFAULT now()
   - CHECK: monto > 0
   - CHECK: metodo = 'efectivo' OR comprobante_path IS NOT NULL (CRITICAL)

9. **RLS on payments:**
   - SELECT: All authenticated (view payments)
   - INSERT: All authenticated (register payment)
   - UPDATE: NONE initially (immutability trigger in 010 will handle)
   - DELETE: NONE (payments cannot be deleted)

10. **RLS on payment_items and payment_methods:**
    - SELECT: All authenticated
    - INSERT: All authenticated
    - UPDATE: NONE
    - DELETE: NONE

11. **Indexes:**
    - CREATE INDEX idx_payments_patient ON payments(patient_id)
    - CREATE INDEX idx_payments_estado ON payments(estado)
    - CREATE INDEX idx_payments_created_at ON payments(created_at DESC)
    - CREATE INDEX idx_payment_items_payment ON payment_items(payment_id)
    - CREATE INDEX idx_payment_methods_payment ON payment_methods(payment_id)
  </action>
  <verify>
```bash
# Check migration has all tables and constraints
grep -E "CREATE TABLE|CREATE TYPE|CHECK|REFERENCES|POLICY" supabase/migrations/009_payments_tables.sql
```
  </verify>
  <done>Migration 009 exists with payments, payment_items, payment_methods tables, invoice_counter with single-row enforcement, get_next_invoice_number function, comprobante_path required for electronic payments, and NO UPDATE/DELETE policies</done>
</task>

</tasks>

<verification>
1. Both migrations created with correct numbering (008, 009)
2. services table has variable price support and admin-only write access
3. payments table has proper FK to patients
4. invoice_counter has single-row enforcement
5. get_next_invoice_number function exists
6. comprobante_path CHECK constraint enforces photo requirement for electronic payments
7. NO UPDATE/DELETE policies on payments (immutability foundation)
</verification>

<success_criteria>
- Migration 008: services table with precio_variable support, RLS (admin write), audit trigger
- Migration 009: payments/payment_items/payment_methods tables, invoice_counter with FOR UPDATE locking, comprobante CHECK constraint
- Both migrations syntactically valid SQL
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments-core/04-01-SUMMARY.md`
</output>
