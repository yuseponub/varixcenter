---
phase: 01-security-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - supabase/migrations/004_audit_user_roles.sql
  - supabase/migrations/005_rls_verification.sql
  - supabase/seed.sql
autonomous: true

must_haves:
  truths:
    - "user_roles table has audit trigger enabled"
    - "All changes to user_roles are captured in audit_log"
    - "RLS verification query returns 0 unprotected tables"
  artifacts:
    - path: "supabase/migrations/004_audit_user_roles.sql"
      provides: "Audit trigger on user_roles"
      contains: "CREATE TRIGGER tr_audit_user_roles"
    - path: "supabase/migrations/005_rls_verification.sql"
      provides: "RLS verification function"
      contains: "public.verify_rls_enabled"
    - path: "supabase/seed.sql"
      provides: "Initial admin user seed"
      contains: "INSERT INTO public.user_roles"
  key_links:
    - from: "tr_audit_user_roles"
      to: "public.audit_trigger_func"
      via: "EXECUTE FUNCTION"
      pattern: "EXECUTE FUNCTION public.audit_trigger_func"
---

<objective>
Enable audit logging on user_roles and create RLS verification tooling.

Purpose: Ensure all role changes are tracked in audit log and provide verification that RLS is enabled on all public tables.
Output: Audit trigger on user_roles, RLS verification function, and seed data for initial admin.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation/01-RESEARCH.md
@.planning/phases/01-security-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable audit on user_roles table</name>
  <files>supabase/migrations/004_audit_user_roles.sql</files>
  <action>
Create migration to add audit trigger to user_roles:

```sql
-- Migration: 004_audit_user_roles.sql
-- Purpose: Enable audit logging on user_roles table

-- Apply audit trigger to user_roles table
-- All role assignments and changes will be tracked
CREATE TRIGGER tr_audit_user_roles
    AFTER INSERT OR UPDATE OR DELETE ON public.user_roles
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_func();

-- Add comment for documentation
COMMENT ON TRIGGER tr_audit_user_roles ON public.user_roles IS
    'Audit trigger: tracks all role assignments and changes in audit_log';

-- Verify trigger exists
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_trigger
        WHERE tgname = 'tr_audit_user_roles'
    ) THEN
        RAISE EXCEPTION 'Audit trigger not created on user_roles';
    END IF;
END $$;
```

This ensures any role change (assignment, modification, removal) is logged with full context (who, what, when, IP).
  </action>
  <verify>
    - File exists at supabase/migrations/004_audit_user_roles.sql
    - Creates trigger tr_audit_user_roles
    - Trigger uses audit_trigger_func
  </verify>
  <done>Audit trigger enabled on user_roles table</done>
</task>

<task type="auto">
  <name>Task 2: Create RLS verification function</name>
  <files>supabase/migrations/005_rls_verification.sql</files>
  <action>
Create migration with RLS verification tools:

```sql
-- Migration: 005_rls_verification.sql
-- Purpose: Tools to verify RLS is enabled on all public tables

-- Function to check if RLS is enabled on all public tables
-- Returns rows only for tables WITHOUT RLS (empty = good)
CREATE OR REPLACE FUNCTION public.verify_rls_enabled()
RETURNS TABLE (
    table_name text,
    rls_enabled boolean,
    warning text
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT
        t.tablename::text,
        t.rowsecurity AS rls_enabled,
        'RLS NOT ENABLED - Security risk!' AS warning
    FROM pg_tables t
    WHERE t.schemaname = 'public'
    AND t.rowsecurity = false
    AND t.tablename NOT IN (
        -- Exclude system/internal tables that don't need RLS
        'schema_migrations'
    )
    ORDER BY t.tablename;
$$;

-- Grant to authenticated users so admins can run verification
GRANT EXECUTE ON FUNCTION public.verify_rls_enabled TO authenticated;

-- Function to get RLS policy summary for a table
CREATE OR REPLACE FUNCTION public.get_rls_policies(target_table text)
RETURNS TABLE (
    policy_name text,
    policy_command text,
    policy_roles text[],
    policy_qual text,
    with_check text
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT
        p.policyname::text,
        p.cmd::text,
        p.roles,
        pg_get_expr(p.qual, p.polrelid)::text,
        pg_get_expr(p.with_check, p.polrelid)::text
    FROM pg_policies p
    WHERE p.schemaname = 'public'
    AND p.tablename = target_table;
$$;

-- Grant to authenticated users
GRANT EXECUTE ON FUNCTION public.get_rls_policies TO authenticated;

-- View for quick RLS status check (admin only via RLS)
CREATE OR REPLACE VIEW public.rls_status AS
SELECT
    t.tablename AS table_name,
    t.rowsecurity AS rls_enabled,
    (SELECT count(*) FROM pg_policies p
     WHERE p.schemaname = 'public' AND p.tablename = t.tablename) AS policy_count,
    CASE
        WHEN t.rowsecurity = false THEN 'VULNERABLE'
        WHEN (SELECT count(*) FROM pg_policies p
              WHERE p.schemaname = 'public' AND p.tablename = t.tablename) = 0 THEN 'RLS ON BUT NO POLICIES'
        ELSE 'SECURED'
    END AS status
FROM pg_tables t
WHERE t.schemaname = 'public'
ORDER BY
    CASE WHEN t.rowsecurity = false THEN 0 ELSE 1 END,
    t.tablename;

-- Grant SELECT on view to authenticated
GRANT SELECT ON public.rls_status TO authenticated;

-- Add comment
COMMENT ON VIEW public.rls_status IS
    'RLS status overview for all public tables. Use verify_rls_enabled() for actionable alerts.';

-- Pre-deployment check function (returns TRUE if all tables secured)
CREATE OR REPLACE FUNCTION public.rls_check_passed()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT NOT EXISTS (
        SELECT 1 FROM public.verify_rls_enabled()
    );
$$;

GRANT EXECUTE ON FUNCTION public.rls_check_passed TO authenticated;
```

These tools allow verification that RLS is properly configured, matching Success Criteria #4: "RLS esta habilitado en TODAS las tablas (verificable con Supabase Security Advisor)"
  </action>
  <verify>
    - File exists at supabase/migrations/005_rls_verification.sql
    - Creates verify_rls_enabled() function
    - Creates rls_status view
    - Creates rls_check_passed() function
  </verify>
  <done>RLS verification functions created for security auditing</done>
</task>

<task type="auto">
  <name>Task 3: Create seed file for initial admin</name>
  <files>supabase/seed.sql</files>
  <action>
Create seed file for setting up initial admin user:

```sql
-- Seed file: supabase/seed.sql
-- Purpose: Initial data setup after migrations

-- INSTRUCTIONS:
-- 1. First, create a user via Supabase Dashboard or Auth API
-- 2. Get the user's UUID from auth.users table
-- 3. Uncomment and run this seed to assign admin role
--
-- This cannot be fully automated because Supabase Auth
-- requires users to be created via the Auth API, not direct SQL.

-- Example: Assign admin role to a user
-- Replace 'YOUR-USER-UUID-HERE' with actual user UUID from auth.users
--
-- INSERT INTO public.user_roles (user_id, role)
-- VALUES ('YOUR-USER-UUID-HERE', 'admin')
-- ON CONFLICT (user_id) DO UPDATE SET role = 'admin';

-- Verification query to check current role assignments
-- Run this after seeding to verify:
--
-- SELECT
--     u.email,
--     ur.role,
--     ur.created_at
-- FROM auth.users u
-- LEFT JOIN public.user_roles ur ON u.id = ur.user_id
-- ORDER BY ur.created_at DESC;

-- Role assignment helper (for use via Supabase Dashboard SQL Editor)
-- This creates a function that admins can use to assign roles:
CREATE OR REPLACE FUNCTION public.assign_role(
    target_email text,
    target_role public.user_role
)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    target_user_id uuid;
    current_role public.user_role;
BEGIN
    -- Check caller is admin
    IF public.get_user_role() != 'admin' THEN
        RAISE EXCEPTION 'Only admins can assign roles';
    END IF;

    -- Find user by email
    SELECT id INTO target_user_id
    FROM auth.users
    WHERE email = target_email;

    IF target_user_id IS NULL THEN
        RAISE EXCEPTION 'User with email % not found', target_email;
    END IF;

    -- Check for existing role
    SELECT role INTO current_role
    FROM public.user_roles
    WHERE user_id = target_user_id;

    IF current_role IS NOT NULL THEN
        -- Update existing role
        UPDATE public.user_roles
        SET role = target_role
        WHERE user_id = target_user_id;

        RETURN format('Updated role for %s: %s -> %s', target_email, current_role, target_role);
    ELSE
        -- Insert new role
        INSERT INTO public.user_roles (user_id, role)
        VALUES (target_user_id, target_role);

        RETURN format('Assigned role %s to %s', target_role, target_email);
    END IF;
END;
$$;

-- Grant execute to authenticated (function checks admin internally)
GRANT EXECUTE ON FUNCTION public.assign_role TO authenticated;

-- Bootstrap function for FIRST admin (can only be called when no admins exist)
-- This allows the first user to bootstrap themselves as admin
CREATE OR REPLACE FUNCTION public.bootstrap_first_admin()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    caller_id uuid;
    admin_count integer;
BEGIN
    -- Get caller's user ID
    caller_id := auth.uid();

    IF caller_id IS NULL THEN
        RAISE EXCEPTION 'Must be authenticated to bootstrap admin';
    END IF;

    -- Check if any admins exist
    SELECT count(*) INTO admin_count
    FROM public.user_roles
    WHERE role = 'admin';

    IF admin_count > 0 THEN
        RAISE EXCEPTION 'Admin already exists. Use assign_role() instead.';
    END IF;

    -- Assign admin role to caller
    INSERT INTO public.user_roles (user_id, role)
    VALUES (caller_id, 'admin')
    ON CONFLICT (user_id) DO UPDATE SET role = 'admin';

    RETURN 'You are now the first admin. Sign out and sign back in to refresh your token.';
END;
$$;

-- Grant execute to authenticated
GRANT EXECUTE ON FUNCTION public.bootstrap_first_admin TO authenticated;

COMMENT ON FUNCTION public.bootstrap_first_admin IS
    'One-time function to bootstrap the first admin user. Fails if any admin exists.';
```

This provides:
1. Manual seed instructions for assigning initial admin
2. assign_role() function for admins to manage roles
3. bootstrap_first_admin() for first-time setup without SQL access
  </action>
  <verify>
    - File exists at supabase/seed.sql
    - Contains assign_role() function
    - Contains bootstrap_first_admin() function
    - Has clear instructions for initial setup
  </verify>
  <done>Seed file created with role management functions</done>
</task>

</tasks>

<verification>
1. All migration files are valid SQL
2. Audit trigger on user_roles references audit_trigger_func
3. verify_rls_enabled() returns empty set for properly configured DB
4. bootstrap_first_admin() allows first-time admin setup
5. assign_role() allows admin to assign roles to other users
</verification>

<success_criteria>
- Audit trigger captures role changes
- RLS verification tools can identify unprotected tables
- First admin can bootstrap without direct SQL access
- Role assignment tracked in audit log
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation/01-04-SUMMARY.md`
</output>
