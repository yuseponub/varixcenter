---
phase: 04-payments-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/010_payments_immutability.sql
  - supabase/migrations/011_payment_receipts_bucket.sql
autonomous: true

must_haves:
  truths:
    - "UPDATE on payments fails except for anulacion state change"
    - "DELETE on payments always fails"
    - "Anulacion requires justificacion text"
    - "Storage bucket exists for payment receipts"
  artifacts:
    - path: "supabase/migrations/010_payments_immutability.sql"
      provides: "Immutability trigger that blocks UPDATE/DELETE"
      contains: "enforce_payment_immutability"
    - path: "supabase/migrations/011_payment_receipts_bucket.sql"
      provides: "Storage bucket for comprobantes"
      contains: "payment-receipts"
  key_links:
    - from: "tr_payment_immutability"
      to: "payments table"
      via: "BEFORE UPDATE OR DELETE trigger"
      pattern: "CREATE TRIGGER tr_payment_immutability"
---

<objective>
Create payment immutability enforcement via database trigger and storage bucket for receipt photos.

Purpose: Make fraud IMPOSSIBLE at the database level. Even service_role cannot bypass triggers.
Output: Two SQL migrations - immutability trigger (010) and storage bucket (011)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-payments-core/04-RESEARCH.md

Reference existing triggers:
@supabase/migrations/002_audit_infrastructure.sql
@supabase/migrations/004_audit_user_roles.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment immutability trigger (010)</name>
  <files>supabase/migrations/010_payments_immutability.sql</files>
  <action>
Create migration 010_payments_immutability.sql with:

1. **enforce_payment_immutability() function:**
   SECURITY DEFINER to run regardless of RLS
   Language: plpgsql

   Logic for DELETE:
   - ALWAYS raise exception: 'Los pagos no pueden ser eliminados. Use anulacion.'

   Logic for UPDATE:
   - Check if ANY immutable field changed (IS DISTINCT FROM):
     * patient_id
     * numero_factura
     * subtotal
     * descuento
     * descuento_justificacion
     * total
     * created_by
     * created_at
   - If ANY changed: raise exception 'Los pagos son inmutables. Solo se permite anulacion.'

   - For estado change specifically:
     * Only allow 'activo' -> 'anulado' transition
     * If OLD.estado != 'activo' OR NEW.estado != 'anulado': raise exception
     * Validate NEW.anulacion_justificacion IS NOT NULL AND != ''
     * Validate NEW.anulado_por IS NOT NULL
     * Set NEW.anulado_at = now() if not set

   - RETURN NEW for valid updates

2. **Create trigger:**
   CREATE TRIGGER tr_payment_immutability
   BEFORE UPDATE OR DELETE ON public.payments
   FOR EACH ROW
   EXECUTE FUNCTION public.enforce_payment_immutability();

3. **Create RPC function for anulacion (admin/medico only):**
   CREATE OR REPLACE FUNCTION public.anular_pago(
     p_payment_id UUID,
     p_justificacion TEXT
   )
   RETURNS JSONB
   LANGUAGE plpgsql
   SECURITY DEFINER
   SET search_path = public
   AS $$
   DECLARE
     v_user_id UUID;
     v_user_role TEXT;
     v_payment RECORD;
   BEGIN
     -- Get current user
     v_user_id := auth.uid();
     IF v_user_id IS NULL THEN
       RAISE EXCEPTION 'No autorizado';
     END IF;

     -- Check role is admin or medico
     SELECT role INTO v_user_role FROM user_roles WHERE user_id = v_user_id;
     IF v_user_role NOT IN ('admin', 'medico') THEN
       RAISE EXCEPTION 'Solo Admin y Medico pueden anular pagos';
     END IF;

     -- Validate justificacion
     IF p_justificacion IS NULL OR LENGTH(TRIM(p_justificacion)) < 10 THEN
       RAISE EXCEPTION 'La justificacion debe tener al menos 10 caracteres';
     END IF;

     -- Get payment and verify estado
     SELECT * INTO v_payment FROM payments WHERE id = p_payment_id;
     IF NOT FOUND THEN
       RAISE EXCEPTION 'Pago no encontrado';
     END IF;
     IF v_payment.estado != 'activo' THEN
       RAISE EXCEPTION 'El pago ya fue anulado';
     END IF;

     -- Perform anulacion (trigger validates immutability)
     UPDATE payments
     SET
       estado = 'anulado',
       anulado_por = v_user_id,
       anulado_at = now(),
       anulacion_justificacion = TRIM(p_justificacion)
     WHERE id = p_payment_id;

     RETURN jsonb_build_object(
       'success', true,
       'payment_id', p_payment_id
     );
   END;
   $$;

4. **Audit trigger for payments:**
   Use existing pattern to log all INSERT and UPDATE (anulacion) to audit_log
  </action>
  <verify>
```bash
# Check trigger and function exist
grep -E "CREATE FUNCTION|CREATE TRIGGER|anular_pago" supabase/migrations/010_payments_immutability.sql
```
  </verify>
  <done>Migration 010 exists with enforce_payment_immutability trigger (blocks UPDATE except anulacion, blocks all DELETE), anular_pago RPC (admin/medico only, validates justificacion 10+ chars), audit trigger for payments</done>
</task>

<task type="auto">
  <name>Task 2: Create storage bucket for payment receipts (011)</name>
  <files>supabase/migrations/011_payment_receipts_bucket.sql</files>
  <action>
Create migration 011_payment_receipts_bucket.sql with:

1. **Create storage bucket:**
   INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
   VALUES (
     'payment-receipts',
     'payment-receipts',
     false,  -- NOT public, requires auth
     5242880,  -- 5MB limit
     ARRAY['image/jpeg', 'image/png', 'image/webp', 'image/heic']
   );

2. **RLS policy for INSERT (upload):**
   CREATE POLICY "Authenticated users can upload receipts"
   ON storage.objects
   FOR INSERT
   TO authenticated
   WITH CHECK (
     bucket_id = 'payment-receipts'
     AND (storage.foldername(name))[1] = 'comprobantes'
   );

3. **RLS policy for SELECT (view):**
   CREATE POLICY "Authenticated staff can view receipts"
   ON storage.objects
   FOR SELECT
   TO authenticated
   USING (
     bucket_id = 'payment-receipts'
   );

4. **NO DELETE policy:**
   Receipts are immutable like payments - no deletion allowed
   Comment explaining this is intentional

5. **NO UPDATE policy:**
   Cannot replace/overwrite receipts
  </action>
  <verify>
```bash
# Check bucket and policies
grep -E "storage.buckets|POLICY|payment-receipts" supabase/migrations/011_payment_receipts_bucket.sql
```
  </verify>
  <done>Migration 011 exists with payment-receipts bucket (5MB limit, image types only), upload policy for authenticated users, view policy for staff, NO delete/update policies (immutable receipts)</done>
</task>

</tasks>

<verification>
1. enforce_payment_immutability function checks all immutable fields
2. Trigger fires BEFORE UPDATE OR DELETE
3. Only estado transition 'activo' -> 'anulado' allowed
4. Anulacion requires non-empty justificacion
5. anular_pago RPC validates admin/medico role
6. Storage bucket has 5MB limit and image-only mime types
7. NO DELETE policy on storage (receipts are evidence)
</verification>

<success_criteria>
- Migration 010: Immutability trigger blocks all harmful operations, anular_pago RPC for safe anulacion
- Migration 011: Storage bucket with proper access control and NO delete capability
- Both migrations syntactically valid SQL
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments-core/04-02-SUMMARY.md`
</output>
