---
phase: 14-returns-workflow
plan: 04
type: execute
wave: 3
depends_on: ["14-02", "14-03"]
files_modified:
  - supabase/migrations/035_medias_cierre_refunds.sql
  - src/lib/queries/medias/returns.ts
  - src/app/(protected)/medias/devoluciones/actions.ts
autonomous: true

must_haves:
  truths:
    - "get_medias_cierre_summary subtracts cash refunds from total_efectivo"
    - "Query functions fetch returns with filters (estado, sale_id)"
    - "Server actions wrap RPC calls with proper error handling"
  artifacts:
    - path: "supabase/migrations/035_medias_cierre_refunds.sql"
      provides: "Updated cierre summary RPC with refund deduction"
      min_lines: 60
    - path: "src/lib/queries/medias/returns.ts"
      provides: "Query functions for returns"
      min_lines: 80
      exports: ["getReturns", "getReturnById", "getReturnsBySale", "getPendingReturnsCount"]
    - path: "src/app/(protected)/medias/devoluciones/actions.ts"
      provides: "Server actions for return lifecycle"
      min_lines: 100
      exports: ["createReturn", "approveReturn", "rejectReturn"]
  key_links:
    - from: "actions.ts"
      to: "RPC functions"
      via: "supabase.rpc"
      pattern: "supabase.*rpc\\('(create|approve|reject)_medias_return'"
    - from: "get_medias_cierre_summary"
      to: "medias_returns"
      via: "refund subtraction"
      pattern: "SELECT.*medias_returns.*metodo_reembolso = 'efectivo'"
---

<objective>
Update cierre calculation to subtract cash refunds, create query functions for returns data, and server actions for return lifecycle operations.

Purpose: Integrates returns with cash closing (DEV-06 cierre impact) and provides data access layer for UI.
Output: Migration for cierre update, queries file, and server actions file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-returns-workflow/14-CONTEXT.md
@.planning/phases/14-returns-workflow/14-RESEARCH.md
@supabase/migrations/025_medias_cierre_rpc.sql
@src/lib/queries/medias/sales.ts
@src/app/(protected)/medias/ventas/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update get_medias_cierre_summary to subtract cash refunds</name>
  <files>supabase/migrations/035_medias_cierre_refunds.sql</files>
  <action>
Create migration that updates get_medias_cierre_summary to account for cash refunds:

```sql
-- Migration: 035_medias_cierre_refunds.sql
-- Purpose: Update cierre summary to subtract approved cash refunds
-- Phase: 14-returns-workflow, Plan: 04
-- Depends on: 025_medias_cierre_rpc.sql, 034_medias_returns_rpc.sql

-- ============================================================================
-- 1. UPDATE get_medias_cierre_summary TO SUBTRACT CASH REFUNDS
-- ============================================================================

CREATE OR REPLACE FUNCTION public.get_medias_cierre_summary(p_fecha DATE)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_total_efectivo DECIMAL(12,2) := 0;
  v_total_tarjeta DECIMAL(12,2) := 0;
  v_total_transferencia DECIMAL(12,2) := 0;
  v_total_nequi DECIMAL(12,2) := 0;
  v_total_devoluciones_efectivo DECIMAL(12,2) := 0;
  v_grand_total DECIMAL(12,2) := 0;
  v_sale_count INTEGER := 0;
  v_return_count INTEGER := 0;
  v_existing_closing UUID;
BEGIN
  -- Check if closing already exists for this date
  SELECT id INTO v_existing_closing
  FROM public.medias_cierres
  WHERE fecha_cierre = p_fecha;

  -- Get totals from medias_sale_methods (for active sales only)
  SELECT
    COALESCE(SUM(CASE WHEN msm.metodo = 'efectivo' THEN msm.monto ELSE 0 END), 0),
    COALESCE(SUM(CASE WHEN msm.metodo = 'tarjeta' THEN msm.monto ELSE 0 END), 0),
    COALESCE(SUM(CASE WHEN msm.metodo = 'transferencia' THEN msm.monto ELSE 0 END), 0),
    COALESCE(SUM(CASE WHEN msm.metodo = 'nequi' THEN msm.monto ELSE 0 END), 0)
  INTO v_total_efectivo, v_total_tarjeta, v_total_transferencia, v_total_nequi
  FROM public.medias_sales ms
  JOIN public.medias_sale_methods msm ON msm.sale_id = ms.id
  WHERE DATE(ms.created_at) = p_fecha
  AND ms.estado = 'activo';

  -- NEW: Get cash refunds approved on this date
  -- IMPORTANT: Uses aprobado_at (approval date), not created_at (request date)
  SELECT COALESCE(SUM(monto_devolucion), 0)
  INTO v_total_devoluciones_efectivo
  FROM public.medias_returns
  WHERE DATE(aprobado_at) = p_fecha
  AND estado = 'aprobada'
  AND metodo_reembolso = 'efectivo';

  -- Get sale count
  SELECT COUNT(*)
  INTO v_sale_count
  FROM public.medias_sales
  WHERE DATE(created_at) = p_fecha
  AND estado = 'activo';

  -- NEW: Get return count for this date
  SELECT COUNT(*)
  INTO v_return_count
  FROM public.medias_returns
  WHERE DATE(aprobado_at) = p_fecha
  AND estado = 'aprobada';

  -- Calculate grand total (unchanged - still total sales)
  v_grand_total := v_total_efectivo + v_total_tarjeta + v_total_transferencia + v_total_nequi;

  -- CRITICAL: Subtract cash refunds from efectivo for reconciliation
  -- Net cash = sales cash - refunds cash
  RETURN jsonb_build_object(
    'fecha', p_fecha,
    'total_efectivo', v_total_efectivo,
    'total_tarjeta', v_total_tarjeta,
    'total_transferencia', v_total_transferencia,
    'total_nequi', v_total_nequi,
    'total_devoluciones_efectivo', v_total_devoluciones_efectivo,
    'efectivo_neto', v_total_efectivo - v_total_devoluciones_efectivo,  -- NEW field
    'grand_total', v_grand_total,
    'sale_count', v_sale_count,
    'return_count', v_return_count,  -- NEW field
    'has_existing_closing', v_existing_closing IS NOT NULL,
    'existing_closing_id', v_existing_closing
  );
END;
$$;

COMMENT ON FUNCTION public.get_medias_cierre_summary IS
  'Calcula totales de ventas medias por metodo de pago, restando devoluciones en efectivo del total. efectivo_neto es lo que debe cuadrar con conteo fisico.';

-- ============================================================================
-- 2. UPDATE create_medias_cierre TO USE efectivo_neto FOR RECONCILIATION
-- ============================================================================

-- Update the create function to compare conteo against efectivo_neto
CREATE OR REPLACE FUNCTION public.create_medias_cierre(
  p_fecha DATE,
  p_conteo_fisico DECIMAL,
  p_diferencia_justificacion TEXT,
  p_cierre_photo_path TEXT,
  p_notas TEXT DEFAULT NULL
)
RETURNS JSONB
-- ... [include full function with efectivo_neto calculation]
-- The key change: v_diferencia := p_conteo_fisico - (v_total_efectivo - v_total_devoluciones_efectivo)
```

Include full create_medias_cierre function update that:
1. Calculates v_total_devoluciones_efectivo from medias_returns
2. Uses v_efectivo_neto := v_total_efectivo - v_total_devoluciones_efectivo
3. Compares conteo_fisico against v_efectivo_neto (not raw v_total_efectivo)

Add verification block confirming functions updated.
  </action>
  <verify>Check efectivo_neto is returned in summary and used for diferencia calculation</verify>
  <done>Cierre summary subtracts cash refunds, efectivo_neto field added for reconciliation</done>
</task>

<task type="auto">
  <name>Task 2: Create query functions for returns</name>
  <files>src/lib/queries/medias/returns.ts</files>
  <action>
Create query file following existing medias/sales.ts pattern:

```typescript
import { createClient } from '@/lib/supabase/server'
import type { MediasReturn, MediasReturnWithDetails, DevolucionEstado } from '@/types/medias/returns'

export interface ReturnFilters {
  estado?: DevolucionEstado
  sale_id?: string
  from_date?: string
  to_date?: string
}

/**
 * Get returns with optional filters
 * Orders by created_at DESC (newest first)
 */
export async function getReturns(filters?: ReturnFilters): Promise<MediasReturnWithDetails[]> {
  const supabase = await createClient()

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let query = (supabase as any)
    .from('medias_returns')
    .select(`
      *,
      sale:medias_sales(
        id,
        numero_venta,
        patient:patients(id, nombre, apellido)
      )
    `)
    .order('created_at', { ascending: false })

  if (filters?.estado) {
    query = query.eq('estado', filters.estado)
  }

  if (filters?.sale_id) {
    query = query.eq('sale_id', filters.sale_id)
  }

  if (filters?.from_date) {
    query = query.gte('created_at', filters.from_date)
  }

  if (filters?.to_date) {
    query = query.lte('created_at', filters.to_date)
  }

  const { data, error } = await query
  if (error) throw error
  return data || []
}

/**
 * Get single return by ID with full details
 */
export async function getReturnById(id: string): Promise<MediasReturnWithDetails | null> {
  // Include solicitante and aprobador emails
}

/**
 * Get returns for a specific sale
 * Used on sale detail page to show return history
 */
export async function getReturnsBySale(saleId: string): Promise<MediasReturn[]> {
  // Filter by sale_id, order by created_at DESC
}

/**
 * Get count of pending returns for badge/dashboard
 */
export async function getPendingReturnsCount(): Promise<number> {
  // COUNT where estado = 'pendiente'
}

/**
 * Get returnable quantity for a sale item
 * = original quantity - (pending + approved returns)
 */
export async function getReturnableQuantity(saleItemId: string): Promise<number> {
  // Used by return form to validate quantity
}
```

Use (supabase as any) pattern for tables not yet in generated types (per 11-05 decision).
  </action>
  <verify>Check queries handle null results and throw errors correctly</verify>
  <done>Query functions for returns created with filters support</done>
</task>

<task type="auto">
  <name>Task 3: Create server actions for returns</name>
  <files>src/app/(protected)/medias/devoluciones/actions.ts</files>
  <action>
Create server actions following existing ventas/actions.ts pattern:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { createReturnSchema, approveReturnSchema, rejectReturnSchema } from '@/lib/validations/medias/return'
import { revalidatePath } from 'next/cache'

/**
 * Action state for return server actions
 */
export type ReturnActionState = {
  error?: string
  errors?: Record<string, string[]>
  success?: boolean
  data?: { id: string; numero_devolucion: string; monto_devolucion: number }
}

/**
 * Create a new return request
 * Any authenticated user can create
 */
export async function createReturn(
  prevState: ReturnActionState | null,
  formData: FormData
): Promise<ReturnActionState> {
  const supabase = await createClient()

  // Auth check
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { error: 'No autorizado. Por favor inicie sesion.' }
  }

  // Parse and validate
  const rawData = {
    sale_id: formData.get('sale_id') as string,
    sale_item_id: formData.get('sale_item_id') as string,
    cantidad: parseInt(formData.get('cantidad') as string, 10),
    motivo: formData.get('motivo') as string,
    metodo_reembolso: formData.get('metodo_reembolso') as string,
    foto_path: (formData.get('foto_path') as string) || null,
  }

  const validated = createReturnSchema.safeParse(rawData)
  if (!validated.success) {
    return {
      errors: validated.error.flatten().fieldErrors as Record<string, string[]>,
      error: 'Por favor corrija los errores en el formulario',
    }
  }

  // Call RPC
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const { data, error } = await (supabase as any).rpc('create_medias_return', {
    p_sale_id: validated.data.sale_id,
    p_sale_item_id: validated.data.sale_item_id,
    p_cantidad: validated.data.cantidad,
    p_motivo: validated.data.motivo,
    p_metodo_reembolso: validated.data.metodo_reembolso,
    p_foto_path: validated.data.foto_path,
  })

  if (error) {
    // Map DB errors to Spanish
    if (error.message.includes('excede')) {
      return { error: error.message }
    }
    if (error.message.includes('10 caracteres')) {
      return { error: 'El motivo debe tener al menos 10 caracteres' }
    }
    return { error: 'Error al crear la devolucion' }
  }

  revalidatePath('/medias/devoluciones')
  revalidatePath('/medias/ventas')
  return { success: true, data }
}

/**
 * Approve a return - Admin/Medico only
 */
export async function approveReturn(...) {
  // Similar pattern, calls approve_medias_return RPC
  // Map 'Solo Admin o Medico' error
}

/**
 * Reject a return - Admin/Medico only
 */
export async function rejectReturn(...) {
  // Similar pattern, calls reject_medias_return RPC
}
```

Include proper error mapping for all RPC error messages.
  </action>
  <verify>Check revalidatePath called for both devoluciones and ventas pages</verify>
  <done>Server actions wrap RPC calls with validation and error handling</done>
</task>

</tasks>

<verification>
1. Migration updates get_medias_cierre_summary with efectivo_neto field
2. create_medias_cierre compares conteo against efectivo_neto (not raw efectivo)
3. Query functions use (supabase as any) pattern for untyped tables
4. Server actions validate with Zod before calling RPC
5. Error messages mapped to Spanish
6. revalidatePath called for affected pages
</verification>

<success_criteria>
- [ ] supabase/migrations/035_medias_cierre_refunds.sql created
- [ ] get_medias_cierre_summary returns total_devoluciones_efectivo and efectivo_neto
- [ ] create_medias_cierre uses efectivo_neto for diferencia calculation
- [ ] src/lib/queries/medias/returns.ts created with all query functions
- [ ] src/app/(protected)/medias/devoluciones/actions.ts created
- [ ] createReturn, approveReturn, rejectReturn actions exported
- [ ] All RPC errors mapped to Spanish user messages
</success_criteria>

<output>
After completion, create `.planning/phases/14-returns-workflow/14-04-SUMMARY.md`
</output>
