---
phase: 04-payments-core
plan: 09
type: execute
wave: 3
depends_on: ["04-05", "04-06", "04-07"]
files_modified:
  - src/components/payments/service-selector.tsx
  - src/components/payments/payment-method-form.tsx
  - src/components/payments/payment-summary.tsx
autonomous: true

must_haves:
  truths:
    - "User can select services and adjust quantity"
    - "Variable price services show editable price input"
    - "Payment methods show comprobante upload for electronic payments"
    - "Summary shows total before submission"
  artifacts:
    - path: "src/components/payments/service-selector.tsx"
      provides: "Multi-service selector with price adjustment"
      contains: "ServiceSelector"
    - path: "src/components/payments/payment-method-form.tsx"
      provides: "Payment method inputs with receipt upload"
      contains: "PaymentMethodForm"
    - path: "src/components/payments/payment-summary.tsx"
      provides: "Payment summary before submit"
      contains: "PaymentSummary"
  key_links:
    - from: "service-selector.tsx"
      to: "types/services.ts"
      via: "ServiceOption type"
      pattern: "ServiceOption"
---

<objective>
Create the core payment form components: service selector, payment methods, and summary.

Purpose: Build reusable components for the payment creation workflow.
Output: Three payment form components that handle the complex payment data entry
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-payments-core/04-RESEARCH.md
@.planning/phases/04-payments-core/04-06-SUMMARY.md

Reference existing components:
@src/components/ui/select.tsx
@src/components/ui/input.tsx
@src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service selector component</name>
  <files>src/components/payments/service-selector.tsx</files>
  <action>
Create src/components/payments/service-selector.tsx with:

```typescript
'use client'

import { useState, useCallback } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Card, CardContent } from '@/components/ui/card'
import { Trash2, Plus } from 'lucide-react'
import type { ServiceOption } from '@/types/services'
import type { PaymentItemInput } from '@/types/payments'

interface ServiceSelectorProps {
  services: ServiceOption[]
  items: PaymentItemInput[]
  onChange: (items: PaymentItemInput[]) => void
  disabled?: boolean
}

const formatCurrency = (amount: number) =>
  new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', minimumFractionDigits: 0 }).format(amount)

export function ServiceSelector({
  services,
  items,
  onChange,
  disabled
}: ServiceSelectorProps) {
  const [selectedServiceId, setSelectedServiceId] = useState<string>('')

  const handleAddService = useCallback(() => {
    if (!selectedServiceId) return

    const service = services.find(s => s.id === selectedServiceId)
    if (!service) return

    // Check if already added
    if (items.some(item => item.service_id === service.id)) {
      // Increment quantity instead
      onChange(items.map(item =>
        item.service_id === service.id
          ? { ...item, quantity: item.quantity + 1 }
          : item
      ))
    } else {
      // Add new item
      onChange([...items, {
        service_id: service.id,
        service_name: service.nombre,
        unit_price: service.precio_base,
        quantity: 1
      }])
    }

    setSelectedServiceId('')
  }, [selectedServiceId, services, items, onChange])

  const handleRemoveItem = useCallback((serviceId: string) => {
    onChange(items.filter(item => item.service_id !== serviceId))
  }, [items, onChange])

  const handleQuantityChange = useCallback((serviceId: string, quantity: number) => {
    if (quantity < 1) return
    onChange(items.map(item =>
      item.service_id === serviceId
        ? { ...item, quantity }
        : item
    ))
  }, [items, onChange])

  const handlePriceChange = useCallback((serviceId: string, price: number) => {
    const service = services.find(s => s.id === serviceId)
    if (!service?.precio_variable) return

    // Clamp to min/max range
    const clampedPrice = Math.min(
      Math.max(price, service.precio_minimo || 0),
      service.precio_maximo || Infinity
    )

    onChange(items.map(item =>
      item.service_id === serviceId
        ? { ...item, unit_price: clampedPrice }
        : item
    ))
  }, [services, items, onChange])

  const getService = (serviceId: string) => services.find(s => s.id === serviceId)

  return (
    <div className="space-y-4">
      <Label>Servicios</Label>

      {/* Service selector */}
      <div className="flex gap-2">
        <Select
          value={selectedServiceId}
          onValueChange={setSelectedServiceId}
          disabled={disabled}
        >
          <SelectTrigger className="flex-1">
            <SelectValue placeholder="Seleccionar servicio..." />
          </SelectTrigger>
          <SelectContent>
            {services.map(service => (
              <SelectItem key={service.id} value={service.id}>
                {service.nombre} - {formatCurrency(service.precio_base)}
                {service.precio_variable && ' (variable)'}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <Button
          type="button"
          variant="outline"
          onClick={handleAddService}
          disabled={disabled || !selectedServiceId}
        >
          <Plus className="h-4 w-4" />
        </Button>
      </div>

      {/* Selected items */}
      <div className="space-y-2">
        {items.map(item => {
          const service = getService(item.service_id)
          const isVariable = service?.precio_variable

          return (
            <Card key={item.service_id}>
              <CardContent className="p-3">
                <div className="flex items-center justify-between gap-2">
                  <div className="flex-1">
                    <p className="font-medium text-sm">{item.service_name}</p>
                    {isVariable && service && (
                      <p className="text-xs text-muted-foreground">
                        Rango: {formatCurrency(service.precio_minimo || 0)} - {formatCurrency(service.precio_maximo || 0)}
                      </p>
                    )}
                  </div>

                  {/* Price input (editable for variable) */}
                  <div className="w-32">
                    <Input
                      type="number"
                      value={item.unit_price}
                      onChange={e => handlePriceChange(item.service_id, parseFloat(e.target.value) || 0)}
                      disabled={disabled || !isVariable}
                      className="text-right"
                      min={service?.precio_minimo || 0}
                      max={service?.precio_maximo || undefined}
                    />
                  </div>

                  {/* Quantity input */}
                  <div className="w-20">
                    <Input
                      type="number"
                      value={item.quantity}
                      onChange={e => handleQuantityChange(item.service_id, parseInt(e.target.value) || 1)}
                      disabled={disabled}
                      min={1}
                      className="text-center"
                    />
                  </div>

                  {/* Subtotal */}
                  <div className="w-28 text-right text-sm font-medium">
                    {formatCurrency(item.unit_price * item.quantity)}
                  </div>

                  {/* Remove button */}
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => handleRemoveItem(item.service_id)}
                    disabled={disabled}
                    className="h-8 w-8 text-destructive"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
              </CardContent>
            </Card>
          )
        })}
      </div>

      {items.length === 0 && (
        <p className="text-sm text-muted-foreground text-center py-4">
          Seleccione al menos un servicio
        </p>
      )}
    </div>
  )
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit src/components/payments/service-selector.tsx 2>&1 | head -20
```
  </verify>
  <done>src/components/payments/service-selector.tsx exists with ServiceSelector that handles multi-service selection, variable price editing within range, quantity adjustment, and removal</done>
</task>

<task type="auto">
  <name>Task 2: Create payment method form component</name>
  <files>src/components/payments/payment-method-form.tsx</files>
  <action>
Create src/components/payments/payment-method-form.tsx with:

```typescript
'use client'

import { useState, useCallback } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Trash2, Plus } from 'lucide-react'
import { ReceiptUpload } from './receipt-upload'
import {
  PAYMENT_METHODS,
  PAYMENT_METHOD_LABELS,
  requiresComprobante,
  type PaymentMethodType,
  type PaymentMethodInput
} from '@/types/payments'

interface PaymentMethodFormProps {
  methods: PaymentMethodInput[]
  onChange: (methods: PaymentMethodInput[]) => void
  totalRequired: number
  disabled?: boolean
}

const formatCurrency = (amount: number) =>
  new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', minimumFractionDigits: 0 }).format(amount)

export function PaymentMethodForm({
  methods,
  onChange,
  totalRequired,
  disabled
}: PaymentMethodFormProps) {
  const handleAddMethod = useCallback(() => {
    // Default to efectivo, with remaining amount
    const currentTotal = methods.reduce((sum, m) => sum + m.monto, 0)
    const remaining = Math.max(0, totalRequired - currentTotal)

    onChange([...methods, {
      metodo: 'efectivo',
      monto: remaining,
      comprobante_path: null
    }])
  }, [methods, onChange, totalRequired])

  const handleRemoveMethod = useCallback((index: number) => {
    onChange(methods.filter((_, i) => i !== index))
  }, [methods, onChange])

  const handleMethodChange = useCallback((index: number, metodo: PaymentMethodType) => {
    onChange(methods.map((m, i) =>
      i === index
        ? { ...m, metodo, comprobante_path: null } // Reset comprobante on method change
        : m
    ))
  }, [methods, onChange])

  const handleAmountChange = useCallback((index: number, monto: number) => {
    onChange(methods.map((m, i) =>
      i === index ? { ...m, monto } : m
    ))
  }, [methods, onChange])

  const handleComprobanteChange = useCallback((index: number, path: string | null) => {
    onChange(methods.map((m, i) =>
      i === index ? { ...m, comprobante_path: path } : m
    ))
  }, [methods, onChange])

  const currentTotal = methods.reduce((sum, m) => sum + m.monto, 0)
  const difference = totalRequired - currentTotal

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <Label>Metodos de Pago</Label>
        <Button
          type="button"
          variant="outline"
          size="sm"
          onClick={handleAddMethod}
          disabled={disabled}
        >
          <Plus className="h-4 w-4 mr-1" />
          Agregar metodo
        </Button>
      </div>

      {methods.map((method, index) => (
        <Card key={index}>
          <CardHeader className="py-3 px-4">
            <div className="flex items-center justify-between">
              <CardTitle className="text-sm">Metodo {index + 1}</CardTitle>
              {methods.length > 1 && (
                <Button
                  type="button"
                  variant="ghost"
                  size="icon"
                  onClick={() => handleRemoveMethod(index)}
                  disabled={disabled}
                  className="h-6 w-6 text-destructive"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </div>
          </CardHeader>
          <CardContent className="pt-0 px-4 pb-4 space-y-4">
            <div className="grid grid-cols-2 gap-4">
              {/* Method select */}
              <div className="space-y-2">
                <Label htmlFor={`method-type-${index}`}>Tipo</Label>
                <Select
                  value={method.metodo}
                  onValueChange={(v) => handleMethodChange(index, v as PaymentMethodType)}
                  disabled={disabled}
                >
                  <SelectTrigger id={`method-type-${index}`}>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {PAYMENT_METHODS.map(m => (
                      <SelectItem key={m} value={m}>
                        {PAYMENT_METHOD_LABELS[m]}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Amount input */}
              <div className="space-y-2">
                <Label htmlFor={`method-amount-${index}`}>Monto</Label>
                <Input
                  id={`method-amount-${index}`}
                  type="number"
                  value={method.monto}
                  onChange={e => handleAmountChange(index, parseFloat(e.target.value) || 0)}
                  disabled={disabled}
                  min={0}
                />
              </div>
            </div>

            {/* Receipt upload for electronic methods */}
            {requiresComprobante(method.metodo) && (
              <ReceiptUpload
                onUploadComplete={(path) => handleComprobanteChange(index, path)}
                onRemove={() => handleComprobanteChange(index, null)}
                initialPath={method.comprobante_path}
                disabled={disabled}
                required
                error={!method.comprobante_path ? 'Comprobante requerido' : undefined}
              />
            )}
          </CardContent>
        </Card>
      ))}

      {methods.length === 0 && (
        <p className="text-sm text-muted-foreground text-center py-4">
          Agregue al menos un metodo de pago
        </p>
      )}

      {/* Total validation message */}
      {methods.length > 0 && Math.abs(difference) > 0.01 && (
        <p className={`text-sm ${difference > 0 ? 'text-amber-600' : 'text-red-600'}`}>
          {difference > 0
            ? `Falta: ${formatCurrency(difference)}`
            : `Excede: ${formatCurrency(Math.abs(difference))}`
          }
        </p>
      )}
    </div>
  )
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit src/components/payments/payment-method-form.tsx 2>&1 | head -20
```
  </verify>
  <done>src/components/payments/payment-method-form.tsx exists with PaymentMethodForm that handles multiple payment methods, shows receipt upload for electronic payments, and validates total matches required amount</done>
</task>

<task type="auto">
  <name>Task 3: Create payment summary component</name>
  <files>src/components/payments/payment-summary.tsx</files>
  <action>
Create src/components/payments/payment-summary.tsx with:

```typescript
'use client'

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Separator } from '@/components/ui/separator'
import { Badge } from '@/components/ui/badge'
import { PAYMENT_METHOD_LABELS, type PaymentMethodInput } from '@/types/payments'
import type { PaymentItemInput } from '@/types/payments'

interface PaymentSummaryProps {
  items: PaymentItemInput[]
  methods: PaymentMethodInput[]
  descuento: number
  descuentoJustificacion: string | null
}

const formatCurrency = (amount: number) =>
  new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', minimumFractionDigits: 0 }).format(amount)

export function PaymentSummary({
  items,
  methods,
  descuento,
  descuentoJustificacion
}: PaymentSummaryProps) {
  const subtotal = items.reduce((sum, item) => sum + item.unit_price * item.quantity, 0)
  const total = subtotal - descuento
  const methodsTotal = methods.reduce((sum, m) => sum + m.monto, 0)
  const isBalanced = Math.abs(total - methodsTotal) < 0.01

  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Resumen del Pago</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Services */}
        <div className="space-y-2">
          <p className="text-sm font-medium text-muted-foreground">Servicios</p>
          {items.map((item, i) => (
            <div key={i} className="flex justify-between text-sm">
              <span>
                {item.service_name}
                {item.quantity > 1 && ` x${item.quantity}`}
              </span>
              <span>{formatCurrency(item.unit_price * item.quantity)}</span>
            </div>
          ))}
        </div>

        <Separator />

        {/* Subtotal */}
        <div className="flex justify-between text-sm">
          <span>Subtotal</span>
          <span>{formatCurrency(subtotal)}</span>
        </div>

        {/* Descuento */}
        {descuento > 0 && (
          <>
            <div className="flex justify-between text-sm text-amber-600">
              <span>Descuento</span>
              <span>-{formatCurrency(descuento)}</span>
            </div>
            {descuentoJustificacion && (
              <p className="text-xs text-muted-foreground italic">
                "{descuentoJustificacion}"
              </p>
            )}
          </>
        )}

        <Separator />

        {/* Total */}
        <div className="flex justify-between font-bold">
          <span>Total</span>
          <span>{formatCurrency(total)}</span>
        </div>

        <Separator />

        {/* Payment methods */}
        <div className="space-y-2">
          <p className="text-sm font-medium text-muted-foreground">Metodos de Pago</p>
          {methods.map((method, i) => (
            <div key={i} className="flex justify-between items-center text-sm">
              <div className="flex items-center gap-2">
                <span>{PAYMENT_METHOD_LABELS[method.metodo]}</span>
                {method.comprobante_path && (
                  <Badge variant="outline" className="text-xs">
                    Con comprobante
                  </Badge>
                )}
              </div>
              <span>{formatCurrency(method.monto)}</span>
            </div>
          ))}
        </div>

        {/* Balance check */}
        {!isBalanced && (
          <div className="text-sm text-red-600 font-medium">
            {methodsTotal > total
              ? `Los metodos exceden el total por ${formatCurrency(methodsTotal - total)}`
              : `Faltan ${formatCurrency(total - methodsTotal)} por asignar`
            }
          </div>
        )}
      </CardContent>
    </Card>
  )
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit src/components/payments/payment-summary.tsx 2>&1 | head -20
```
  </verify>
  <done>src/components/payments/payment-summary.tsx exists with PaymentSummary that shows services, subtotal, descuento, total, payment methods, and validates balance</done>
</task>

</tasks>

<verification>
1. All three components compile without TypeScript errors
2. ServiceSelector handles variable price within min/max range
3. PaymentMethodForm shows ReceiptUpload only for electronic methods
4. PaymentSummary shows balance validation
5. Currency formatted as Colombian pesos
6. Components use existing UI primitives (Card, Select, Input, Button)
</verification>

<success_criteria>
- src/components/payments/service-selector.tsx: Multi-service with variable price
- src/components/payments/payment-method-form.tsx: Split payments with comprobante
- src/components/payments/payment-summary.tsx: Full summary with validation
- All files compile and use proper types
</success_criteria>

<output>
After completion, create `.planning/phases/04-payments-core/04-09-SUMMARY.md`
</output>
