---
phase: 03-appointments
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/app/(protected)/citas/actions.ts
autonomous: true

must_haves:
  truths:
    - "User can create appointment linked to existing patient"
    - "Appointment status can be updated following state machine rules"
    - "Appointments can be rescheduled via drag-drop"
    - "Overlap error returns user-friendly Spanish message"
  artifacts:
    - path: "src/app/(protected)/citas/actions.ts"
      provides: "Server actions for appointment CRUD"
      exports: ["createAppointment", "updateAppointmentStatus", "rescheduleAppointment"]
  key_links:
    - from: "src/app/(protected)/citas/actions.ts"
      to: "appointments table"
      via: "supabase insert/update"
      pattern: "from\\('appointments'\\)"
    - from: "src/app/(protected)/citas/actions.ts"
      to: "state-machine"
      via: "import canTransition"
      pattern: "import.*canTransition"
---

<objective>
Create server actions for appointment CRUD operations with Zod validation and state machine enforcement.

Purpose: Provide the server-side logic for creating appointments, updating status, and handling drag-drop reschedule.
Output: Server actions following useActionState pattern with proper error handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-appointments/03-RESEARCH.md
@.planning/phases/02-patients/02-04-SUMMARY.md
@src/app/(protected)/pacientes/nuevo/actions.ts
@src/lib/validations/appointment.ts
@src/lib/appointments/state-machine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create appointment server actions</name>
  <files>src/app/(protected)/citas/actions.ts</files>
  <action>
Create `src/app/(protected)/citas/actions.ts` following the pattern from patient actions:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import {
  appointmentSchema,
  appointmentStatusSchema,
  appointmentRescheduleSchema
} from '@/lib/validations/appointment'
import { canTransition } from '@/lib/appointments/state-machine'
import { AppointmentStatus } from '@/types/appointments'

/**
 * Action state type for useActionState
 * Follows established pattern from 02-04
 */
type ActionState = {
  success: boolean
  message: string
  errors?: Record<string, string[]>
}

/**
 * Create a new appointment
 *
 * Used by: New appointment form
 * Handles overlap constraint error (23P01) with user-friendly message
 */
export async function createAppointment(
  prevState: ActionState,
  formData: FormData
): Promise<ActionState> {
  const supabase = await createClient()

  // Get current user for audit
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, message: 'No autorizado' }
  }

  // Parse and validate form data
  const rawData = {
    patient_id: formData.get('patient_id'),
    doctor_id: formData.get('doctor_id'),
    fecha_hora_inicio: formData.get('fecha_hora_inicio'),
    fecha_hora_fin: formData.get('fecha_hora_fin'),
    notas: formData.get('notas') || null,
    motivo_consulta: formData.get('motivo_consulta') || null
  }

  const result = appointmentSchema.safeParse(rawData)
  if (!result.success) {
    return {
      success: false,
      message: 'Datos invalidos',
      errors: result.error.flatten().fieldErrors as Record<string, string[]>
    }
  }

  // Insert appointment - exclusion constraint handles overlap prevention
  const { error } = await supabase
    .from('appointments')
    .insert({
      patient_id: result.data.patient_id,
      doctor_id: result.data.doctor_id,
      fecha_hora_inicio: result.data.fecha_hora_inicio,
      fecha_hora_fin: result.data.fecha_hora_fin,
      notas: result.data.notas,
      motivo_consulta: result.data.motivo_consulta,
      estado: 'programada',
      created_by: user.id
    })

  if (error) {
    console.error('Create appointment error:', error)

    // 23P01: exclusion constraint violation (overlapping appointment)
    if (error.code === '23P01') {
      return {
        success: false,
        message: 'El medico ya tiene una cita programada en ese horario'
      }
    }

    // 23503: foreign key violation (invalid patient or doctor)
    if (error.code === '23503') {
      return {
        success: false,
        message: 'Paciente o medico no encontrado'
      }
    }

    return { success: false, message: 'Error al crear la cita' }
  }

  revalidatePath('/citas')
  return { success: true, message: 'Cita creada exitosamente' }
}

/**
 * Update appointment status
 *
 * Used by: Status buttons/dropdown in calendar
 * Validates transition against state machine
 */
export async function updateAppointmentStatus(
  appointmentId: string,
  prevState: ActionState,
  formData: FormData
): Promise<ActionState> {
  const supabase = await createClient()

  // Get current user
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, message: 'No autorizado' }
  }

  // Validate new status
  const newStatus = formData.get('estado') as string
  const statusResult = appointmentStatusSchema.safeParse({ estado: newStatus })

  if (!statusResult.success) {
    return {
      success: false,
      message: 'Estado invalido',
      errors: statusResult.error.flatten().fieldErrors as Record<string, string[]>
    }
  }

  // Get current appointment status
  const { data: appointment, error: fetchError } = await supabase
    .from('appointments')
    .select('estado')
    .eq('id', appointmentId)
    .single()

  if (fetchError || !appointment) {
    return { success: false, message: 'Cita no encontrada' }
  }

  // Validate state transition using state machine
  const currentStatus = appointment.estado as AppointmentStatus
  const targetStatus = statusResult.data.estado

  if (!canTransition(currentStatus, targetStatus)) {
    return {
      success: false,
      message: `No se puede cambiar de "${currentStatus}" a "${targetStatus}"`
    }
  }

  // Update status
  const { error: updateError } = await supabase
    .from('appointments')
    .update({ estado: targetStatus })
    .eq('id', appointmentId)

  if (updateError) {
    console.error('Update appointment status error:', updateError)
    return { success: false, message: 'Error al actualizar el estado' }
  }

  revalidatePath('/citas')
  return { success: true, message: 'Estado actualizado' }
}

/**
 * Reschedule appointment (drag-drop in calendar)
 *
 * Used by: Calendar eventDrop handler
 * Only changes time, preserves other fields
 */
export async function rescheduleAppointment(
  appointmentId: string,
  newStart: string,
  newEnd: string
): Promise<ActionState> {
  const supabase = await createClient()

  // Get current user
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, message: 'No autorizado' }
  }

  // Validate time data
  const result = appointmentRescheduleSchema.safeParse({
    fecha_hora_inicio: newStart,
    fecha_hora_fin: newEnd
  })

  if (!result.success) {
    return {
      success: false,
      message: result.error.errors[0]?.message || 'Horario invalido'
    }
  }

  // Update appointment time
  const { error } = await supabase
    .from('appointments')
    .update({
      fecha_hora_inicio: result.data.fecha_hora_inicio,
      fecha_hora_fin: result.data.fecha_hora_fin
    })
    .eq('id', appointmentId)

  if (error) {
    console.error('Reschedule appointment error:', error)

    // 23P01: exclusion constraint violation
    if (error.code === '23P01') {
      return {
        success: false,
        message: 'El medico ya tiene una cita en ese horario'
      }
    }

    return { success: false, message: 'Error al reprogramar la cita' }
  }

  revalidatePath('/citas')
  return { success: true, message: 'Cita reprogramada' }
}

/**
 * Delete appointment (admin only, prefer cancel instead)
 *
 * Used by: Admin action menu (rare use case)
 */
export async function deleteAppointment(
  appointmentId: string
): Promise<ActionState> {
  const supabase = await createClient()

  // Get current user
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { success: false, message: 'No autorizado' }
  }

  // RLS policy will enforce admin-only delete
  const { error } = await supabase
    .from('appointments')
    .delete()
    .eq('id', appointmentId)

  if (error) {
    console.error('Delete appointment error:', error)

    // Check for permission denied (RLS)
    if (error.code === '42501') {
      return {
        success: false,
        message: 'Solo administradores pueden eliminar citas'
      }
    }

    return { success: false, message: 'Error al eliminar la cita' }
  }

  revalidatePath('/citas')
  return { success: true, message: 'Cita eliminada' }
}
```
  </action>
  <verify>
- File exists at `src/app/(protected)/citas/actions.ts`
- `npm run build` passes
- createAppointment, updateAppointmentStatus, rescheduleAppointment are exported
- State machine canTransition is used in updateAppointmentStatus
  </verify>
  <done>
- createAppointment validates with Zod, handles overlap error with Spanish message
- updateAppointmentStatus validates transitions with canTransition()
- rescheduleAppointment handles drag-drop time changes
- deleteAppointment for admin fallback (RLS enforced)
- All actions follow useActionState (prevState, formData) pattern
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. All server actions have 'use server' directive
3. createAppointment handles 23P01 (overlap) with Spanish message
4. updateAppointmentStatus uses canTransition from state machine
5. All actions revalidate '/citas' path
</verification>

<success_criteria>
- Appointment creation linked to existing patient (requirement from Success Criteria #4)
- Overlap prevention returns "El medico ya tiene una cita programada en ese horario"
- Status updates enforce state machine transitions
- Drag-drop reschedule updates time only
- Error messages in Spanish
</success_criteria>

<output>
After completion, create `.planning/phases/03-appointments/03-04-SUMMARY.md`
</output>
